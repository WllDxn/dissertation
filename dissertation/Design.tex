\documentclass[12pt]{article}
\usepackage[a4paper, total={6in, 9.25in}]{geometry}
%opening

\usepackage[]{algorithmic, algorithm, letltxmacro}
\usepackage{eqparbox}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{array}
\newlength{\commentindent}
\setlength{\commentindent}{.5\textwidth}
\makeatletter
\renewcommand{\algorithmiccomment}[1]{\unskip\hfill\makebox[\commentindent][l]{$\triangleright$~#1}\par}
\LetLtxMacro{\oldalgorithmic}{\algorithmic}
\renewcommand{\algorithmic}[1][0]{%
	\oldalgorithmic[#1]%
	\renewcommand{\ALC@com}[1]{%
		\ifnum\pdfstrcmp{##1}{default}=0\else\algorithmiccomment{##1}\fi}%
}
\newcommand{\minus}{\scalebox{0.75}[1.0]{$-$}}
\makeatother
\renewcommand\algorithmicrequire{\textbf{Input:}}
\renewcommand\algorithmicensure{\textbf{Output:}}

\setcounter{secnumdepth}{4}
\titleformat{\section}
{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\normalsize\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}
\titleformat{\paragraph}[runin]
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titleformat{\subparagraph}[runin]
{\normalfont\normalsize\bfseries}{\thesubparagraph}{1em}{}

\begin{document}
	\section{Design}
	This is an implementation in pseudocode of all 4 components of the radix sort variations included in this project: Radix sort starting from the most significant and least significant digit and then the integer sorting methods Counting sort and Pigeonhole sort. Each permutation of Radix sort takes the input array \textit{A} of integers and treats each item \textit{A[i]} as a series of digits d within the range 0 \textit{$\leq$ d $<$ k} where \textit{k} is the radix or the number of unique digits. 
	\subsection{Integer Sorting}
	Integer sorting is the underlying sorting method that is applied to each digit of the input array, these methods are non-comparitive algorithms that distribute items based on the value of each digit. 
	\subsubsection{Pigeonhole Sort}
	Pigeonhole sort operates by instantiating an array \textit{B} of length \textit{k} (1) containing empty arrays (3). The input array \textit{A} is iterated over and each item \textit{A[i]} is appended to the array in \textit{B} at the position that corresponds to the current digit of the current item. \textit{B} is then iterated over (10) and each item in each array overwrites the original array in order (11). 
	\begin{algorithm}[H] % enter the algorithm environment
		\caption{Pigeonhole Sort({A})} % give the algorithm a caption
		\label{alg1} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum value $k$
			\ENSURE Sorted Array
			\STATE $B \Leftarrow [1..k]$ \COMMENT{Buckets array}
			\FOR{$i\gets 1$ to $k$}
			\STATE $B[i] \Leftarrow [$\space$]$ \COMMENT{Each bucket contains empty array}
			\ENDFOR
			\FOR{$j\gets 1$ to $k$}
			\STATE $append$\space$ A[j]$\space$ to$\space$ B[A[j]]$ \COMMENT{Move item to bucket}
			\ENDFOR
			\STATE $c \Leftarrow 1$ \COMMENT{Count items in A}
			\FOR{$i\gets 1$ to $k$}
			\FORALL{$item$ in $B[i]$}
			\STATE $A[c] \Leftarrow item$ \COMMENT{Move items from bucket to A}
			\STATE $c \Leftarrow c + 1$
			\ENDFOR
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}

	\pagebreak
	\subsubsection{Counting Sort}
	Counting sort instantiates 2 arrays; \textit{B}, the output array equal in length to the input array \textit{A} (1), and \textit{C}, a count array to store the frequency of each digit which is of length \textit{k} and is instantiated to contain only integers of value 0 (2, 4). The input array is iterated over and the integer in C at the position equal to the current digit of the current item is incremented (7), producing a histogram of the frequency of each digit. This count list is then accumulated such that each item is added to the sum of the previous values (10). Finally the input array is iterated over in reverse and each item is moved to the output array in the position that is referred to by the value expressed in the count array at the position of the current digit of the current item(13), to ensure that values to not overwrite one another in the output array each item in the count array is decremented when a position in the output array is taken from it (14).
	\begin{algorithm}[H] % enter the algorithm environment
		\caption{Counting Sort({A})} % give the algorithm a caption
		\label{alg2} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#					
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum value $k$
			\ENSURE Sorted Array
			\STATE $B \Leftarrow [1..n]$ \COMMENT{Temp array}
			\STATE $C \Leftarrow [1..k]$ \COMMENT{Count array}
			\FOR{$i\gets 1$ to $k$}
				\STATE $C \Leftarrow 0$
			\ENDFOR
			\FOR{$j\gets 1$ to $n$}
				\STATE $C[A[j]] \Leftarrow C[A[j]] + 1$ \COMMENT{Count occurence of value}
			\ENDFOR
			\FOR{$i\gets 2$ to $k$}
				\STATE $C[i] \Leftarrow C[i] + C[i-1]$\COMMENT{Accumulate Count array}
			\ENDFOR
			\FOR{$j\gets n$ to $1$ by $-1$}
				\STATE $B[C[A[j]]] \Leftarrow A[J]$ \COMMENT{Move item from input to temp array}
				\STATE $C[A[j]] \Leftarrow C[A[j]] - 1$ \COMMENT{Deincrement count array}
			\ENDFOR
			\STATE \textbf{return} $B$
		\end{algorithmic}
	\end{algorithm}	
	\pagebreak
	\subsection{Radix Sort}
	Radix sort is the method of applying the integer sorting method to each digit of the input, there are two approaches to this: Least significant digit first (LSD) or Most significant digit first (MSD).
	\subsubsection{Least Significant Digit}
	Least Significant Digit Radix sort (LSD) takes an input array \textit{A} and sorting function \textit{f()} which can be either of the previous integer sorting methods. The input array is sorted via the chosen method once for each of digits in the chosen radix of the largest value (3) This sorting process is applied first at the least significant or rightmost digit and moves incrementally to the most significant or leftmost digit. Values can have an unequal number of digits provided any digits farther left than their most significant are taken as 0 and the chosen integer sorting method is stable as this means they maintain their relative position with respect to values that have an equal or lesser number of digits.
	
	\begin{algorithm} % enter the algorithm environment
		\caption{LSD({A, f()})} % give the algorithm a caption
		\label{alg3} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum absolute Value $k$
			\REQUIRE $f() \Leftarrow $Sorting function \COMMENT{Pigeonhole or Counting Sort}
			\ENSURE Sorted Array
			\STATE $d \Leftarrow$ Number of digits of k \COMMENT{Varies based on radix chosen}
			\STATE $A(i) \Leftarrow$ i-th digit of each item in A
			\FOR{$i\gets 1$ to $d$}
				\STATE $A \Leftarrow f(A(i))$ \COMMENT{Sorts Array using sort function}
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}
	\pagebreak
	\subsubsection{Most Significant Digit}
	Most Significant Digit Radix sort (MSD) takes an input array \textit{A}, sorting function \textit{f()} and current digit \textit{i} which for the first call of the function should be the number of digits of the largest value in the input. This algorithm operates recursively, and the termination condition occurs when \textit{i} is equal to 0 meaning that all digits of the input have been sorted (1,2). After ensuring the termination condition has not been met the input array \textit{A} is then sorted using the chosen function with respect to the current digit (5). The input array is then iterated over and items that have an equal value at the current digit are identified (8) and taken as a slice of the input array. This slice is then sorted recursively using a function call to \textit{MSD()} with a decremented value for \textit{i}  meaning they are sorted over the next least significant digit (11). Once the termination condition has been reached within this slice and all sub-slices created by recursive calls the algorithm resets the start point of the slice and identifies further slices to sort (12).
	\begin{algorithm} % enter the algorithm environment
		\caption{MSD({A, i, f()})} % give the algorithm a caption
		\label{alg4} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum absolute Value $k$
			\REQUIRE $i \Leftarrow$ Digit to sort Array on \COMMENT{start with number of digits of k}
			\REQUIRE Sorting function $f()$\COMMENT{Pigeonhole or Counting Sort}
			\ENSURE Sorted Array
			\IF{$i==0$}
				\STATE \textbf{return} $A$
			\ENDIF
			\STATE $A(i) \Leftarrow$ i-th digit of each item in A
			\STATE $A \Leftarrow f(A(i))$ \COMMENT{Sorts Array using sort function}
			\STATE $s \Leftarrow 1$ \COMMENT{Starting position of recursive call}
			\FOR{$j\gets 1$ to $s$}
				\IF{$A(i)[j] == A(i)[s]$}
					\STATE Do Nothing
				\ELSE
					\STATE $A[s..j-1] \Leftarrow MSD(A[s..j-1](i), i-1)$
					\STATE $s \Leftarrow j$ \COMMENT{Reset start position of array slice}
				\ENDIF
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}
	\pagebreak
	\section{Time complexity}
	\subsection{Integer Sorting}
	Counting and Pigeonhole sort both have a time complexity of $\mathcal{O}\textit{(n+k)}$ where \textit{n} is the number of items in the input array and \textit{k} is the maximum range of input values, this can be seen as one pass over the input data containing \textit{n} items and one pass over the intermediary buckets array for pigeonhole sort or the count array for counting sort, both of which contain \textit{k} items.
	\newline
	\subsection{Radix Sort}
	Radix sort repeatedly applies integer sorting to each successive digit of the input array, it differs from counting sort in that it does not sort into \textit{k} buckets but a constant base \textit{b} is chosen. It repeats the integer sorting method \textit{d} times where \textit{d} is the number of passes necessary to sort each digit of the maximum value in the input with respect to the base \textit{b} and can be expressed as \textit{d = $log_b$k}
	\newline
	This gives a time complexity of	$\mathcal{O}$\textit{((n + b) $\cdot$ d)} or if we select some constant value for \textit{b}; $\mathcal{O}$\textit{(n $\cdot$ d)}
	\newline However, in the application of this project, radix sort will only be applied to integers represented in 64-bits, meaning there is a defined upper bound to the max value \textit{k}. This is important because it means that that \textit{k} is polynomial in \textit{b} or that \textit{k} is always able to be represented by \textit{b} raised to some exponent \textit{c} where \textit{c} is some constant value. This can be expressed in the form \textit{k $=$ b$^{\mathcal{O}(1)}$} or \textit{$\mathcal{O}(1) = log_b$k}
	\newline
	\textit{$\mathcal{O}(1)$} can be substituted in for \textit{d} in the time complexity analysis meaning Radix sort will run in $\mathcal{O}$\textit{(n)} or linear time in the context of this project.
	\pagebreak
	\section{Radix Selection}
	\subsection{Introduction}
	Radix sort utilises repeated rounds of integer sorting across each digit of the input array, therefore, it is necessary to make a clear definition of a digit so that an effective method of separating an integer into its component digits can be implemented. When expressing a number a base must first be decided, this is the number of unique digits that can be displayed at any position and when a value exceeds the maximum value within this base another digit must be added; i.e. in standard decimal or base 10 numbers 0 through 9 can be expressed in a single digit but increasing beyond this range requires adding a second digit to create the number 10. Though we typically think of numbers in the context of arabic numerals in the decimal system, this is a social convention which this algorithm is not beholden to and as Radix sort fundamentally relies on the processing of the component digits of an integer it is of great importance that an appropriate base is selected as well as an efficient method for processing each digit.
	\subsection{Explanation}
	Bases that are of the order 2n where n is some integer are the most suitable for a typical radix sort algorithm, this is because bases that fit this specification allow for easy conversion from binary which is how the computer on which the algorithm runs stores numbers. Any base of 2n will utilise all possible combinations of n digits of binary to express a single digit, meaning, to sort integers across a given digit it is possible to extract a known quantity of binary values at a known position within the binary representation of the integer. Provided it is possible and efficient to extract the binary value of an integer within a programming language, this approach is significantly superior to working in base 10 as it requires no mathematical calculations to be performed on each input item whereas working with base 10 would require some kind of use of the modulo or remainder functions or a type conversion to a string; both of these options are significantly more resource intensive.
	\subsection{Implementation}
	Python stores integers in “two’s complement” binary and allocates 64 bits, this means that by utilising the in-built python bitwise operations it is possible to quickly manipulate integers and acquire the digit in any position so long as the base is an exponent of 2.
	\newline
	As an example, selecting a base of $2^{4}$ (16) and Radix sort from the least significant digit, utilising the bitwise “and” operation on a chosen integer with 15 (the largest integer that can be expressed in 4 bits (1 1 1 1 in binary) and find the digit in the rightmost position and use that for integer sorting. Then to move on to the next most significant digit we can perform a “right shift” of 4 bits, discarding the bits representing the already sorted digit and moving the bits representing the next digit into the rightmost position and allowing the same “and” operation as used previously to identify the digit.
	\pagebreak
	\section{Negative Integers}
	\subsection{Two's Complement}
	When handling integers in two’s complement, positives are represented in binary, but with a leading 0 in the leftmost position to indicate the positive sign of the integer. Negative integers are represented with a leading 1 which represents that the binary value of this digit is to be subtracted i.e. negative and all other binary digits are positive such that the sum of all the digits equals the integer being represented. table reference has been included to illustrate this, as you can see the value $+3$ has a leading $0$ at index $2$, representing $2^{2}$ is not subtracted, this is followed by 1 in all remaining digits representing the addition of $2^{1}$ and $2^{0}$ or $2+1=3$. $\minus3$ is represented by a leading 1 to represent $\minus2^{2}$ followed by 0 1 to represent no addition of $2^{1}$ and the addition of $2^{0}$ or $\minus4 + 1 = \minus3$.
	\newline
	The effect of performing Radix sorting without any accommodation for negativity is that due to the leading 1, negative values will be incorrectly sorted ahead of positive values as though they were larger. They will also be sorted into the correct order relative to other negative values (increasing from most negative to least negative), as among values that can be represented in the same number of bits the more negative numbers have fewer additional bits in positions to the right, for example $\minus4$ is 100 and $\minus 3$ is 101.
	\newline
	The method of correcting for this problem is to invert the sign bit using a bitwise “exclusive or” operation with a 1 in the position of the sign bit or more accurately performing this operation against $1 +$ the largest integer possible with the current machine word length. This operation gives 1 if the sign bit of the integer is 0 or 0 if the sign bit is 1. Following this it must be ensured the integer sorting method sorts across the sign bit either at the start for MSD or at the end for LSD, this preserves the relative order amongst positive and negative integers but ensures this pass of the data sorts the items such that negatives come before positives.
	\subsubsection{Two's complement three bit integers}
	\begin{table}[!h]
	\begin{center}
		\begin{tabular}{|c |c |c|} 
		 \hline
		 Bits & Unsigned Value & \begin{tabular}{c}Signed Value\\(Two's Complement)\end{tabular}\\
		 \hline\hline
		 000 & 0 & 0  \\ 
		 \hline
		 001 & 1 & 1  \\
		 \hline
		 010 & 2 & 2  \\
		 \hline
		 011 & 3 & 3  \\
		 \hline
		 100 & 4 & -4  \\ 
		 \hline
		 101 & 5 & -3  \\  
		 \hline
		 101 & 6 & -2  \\ 
		 \hline
		 111 & 7 & -1  \\ 
		 \hline
		\end{tabular}
		\end{center}
	\end{table}


	\pagebreak
	\subsection{Implementation}
	The purpose of this project was to incorporate this sorting algorithm into the standard library for Pypy, meaning it had to be written in RPython, the language used for Pypy. RPython is a restricted form of python, specifically it is a form of Python 2, which is relevant to the handling of integers as RPython inherits Python2’s method of allocation of a quantity of bits for each integer equal to the word size of the machine it is being run on (typically this is 32 or 64 bits), even if the integer can be expressed in fewer bits. The leftmost bit represents whether the integer is positive or negative and the remaining bits represent the magnitude of the integer, all digits between the sign bit and the most significant bit needed to represent the integer are copies of the sign bit. To put this in the context of two’s complement , this representation can be understood as the first bit representing $\minus2^{m}$ where m is the machine word length and all following digits are additions of $2^{n}$ where n is $[m-1..0]$.
	\newline
	\newline
	The true sign bit, meaning the bit that always and exclusively represents the sign of the integer, is the one in the leftmost position, however it is not necessarily the most optimal solution to this problem of negatives being sorted into the incorrect position to flip this bit. Firstly, when sorting integers that take up a small number of bits it would require some additional logical test to identify if the algorithm is performing the first (for MSD) or last (for LSD) pass of the data to then instruct the algorithm to jump to the leftmost bit. Additionally, it is necessary to identify the machine word length of the machine on which this code is running as flipping the 64th bit on a 32 bit machine is not possible, this eliminates the possibility of a hardcoded value and essentially forces the use of the “sys.maxint” function from the Python 2 standard library. I decided that using this function was not in the best interest of this project for posterity as it was removed from Python 3 and replaced with “sys.maxsize” which means if RPython ever moved on to Python 3 this function would stop working; whilst this is a minor issue that would likely never cause problems there is an alternative solution without any issues.
	\newline
	\newline
	The approach used in this project was to identify the number of digits needed to express the largest absolute value of the input in the chosen base and then flip the leftmost bit of the digit preceding this digit. So for example the integer 246 when expressed in base 4  (equal to $2^{2}$ or 8 bits) requires 4 digits [3312], so in RPython the preceding bits are all 0 to indicate the sign being positive, this method then identifies the bits that would represent the next digit (the bits 9th and 10th from the right) and flips the leftmost digit giving it the binary value of [10] and a digit value of 2 in base 4. This dynamic approach ensures that the relative correct order within the positive and negative integers is preserved  and is suitable for use with any integers being sorted in any base.


	
	
	\end{document}