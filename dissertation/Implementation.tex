\documentclass[12pt]{article}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage[a4paper, total={6in, 9.25in}]{geometry}
%opening
\usepackage{xcolor}
\usepackage[]{algorithmic, algorithm, letltxmacro}
\usepackage{eqparbox}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{array}
\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}
\usepackage{hhline}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
\newlength{\commentindent}
\setlength{\commentindent}{.5\textwidth}
\makeatletter
\renewcommand{\algorithmiccomment}[1]{\unskip\hfill\makebox[\commentindent][l]{$\triangleright$~#1}\par}
\LetLtxMacro{\oldalgorithmic}{\algorithmic}
\renewcommand{\algorithmic}[1][0]{%
	\oldalgorithmic[#1]%
	\renewcommand{\ALC@com}[1]{%
		\ifnum\pdfstrcmp{##1}{default}=0\else\algorithmiccomment{##1}\fi}%
}
\newcommand{\minus}{\scalebox{0.75}[1.0]{$-$}}
\makeatother
\renewcommand\algorithmicrequire{\textbf{Input:}}
\renewcommand\algorithmicensure{\textbf{Output:}}

\setcounter{secnumdepth}{4}
\titleformat{\section}
{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\normalsize\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}
\titleformat{\paragraph}[runin]
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titleformat{\subparagraph}[runin]
{\normalfont\normalsize\bfseries}{\thesubparagraph}{1em}{}

\usepackage[font=small,skip=0pt,justification=centering]{caption}
\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
  }
\begin{document}
\section{Design}
\label{sec:design}

	This is an implementation in pseudocode of all 4 components of the radix sort variations included in this project: Radix sort starting from the most significant and least significant digit and then the integer sorting methods Counting sort and Pigeonhole sort. Each permutation of Radix sort takes the input array \textit{A} of integers and treats each item \textit{A[i]} as a series of digits d within the range 0 \textit{$\leq$ d $<$ k} where \textit{k} is the radix or the number of unique digits. 
	\subsection{Integer Sorting}
	Integer sorting is the underlying sorting method that is applied to each digit of the input array, these methods are non-comparitive algorithms that distribute items based on the value of each digit. 
	\subsubsection{Pigeonhole Sort}
	Pigeonhole sort operates by instantiating an array \textit{B} of length \textit{k} (1) containing empty arrays (3). The input array \textit{A} is iterated over and each item \textit{A[i]} is appended to the array in \textit{B} at the position that corresponds to the current digit of the current item. \textit{B} is then iterated over (10) and each item in each array overwrites the original array in order (11). 
	\begin{algorithm}[H] % enter the algorithm environment
		\caption{Pigeonhole Sort({A})} % give the algorithm a caption
		\label{alg1} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum value $k$
			\ENSURE Sorted Array
			\STATE $B \Leftarrow [1..k]$ \COMMENT{Buckets array}
			\FOR{$i\gets 1$ to $k$}
			\STATE $B[i] \Leftarrow [$\space$]$ \COMMENT{Each bucket contains empty array}
			\ENDFOR
			\FOR{$j\gets 1$ to $k$}
			\STATE $append$\space$ A[j]$\space$ to$\space$ B[A[j]]$ \COMMENT{Move item to bucket}
			\ENDFOR
			\STATE $c \Leftarrow 1$ \COMMENT{Count items in A}
			\FOR{$i\gets 1$ to $k$}
			\FORALL{$item$ in $B[i]$}
			\STATE $A[c] \Leftarrow item$ \COMMENT{Move items from bucket to A}
			\STATE $c \Leftarrow c + 1$
			\ENDFOR
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}

	\pagebreak
	\subsubsection{Counting Sort}
	\label{ssec:counting}
	Counting sort instantiates 2 arrays; \textit{B}, the output array equal in length to the input array \textit{A} (1), and \textit{C}, a count array to store the frequency of each digit which is of length \textit{k} and is instantiated to contain only integers of value 0 (2, 4). The input array is iterated over and the integer in C at the position equal to the current digit of the current item is incremented (7), producing a histogram of the frequency of each digit. This count list is then accumulated such that each item is added to the sum of the previous values (10). Finally the input array is iterated over in reverse and each item is moved to the output array in the position that is referred to by the value expressed in the count array at the position of the current digit of the current item(13), to ensure that values to not overwrite one another in the output array each item in the count array is decremented when a position in the output array is taken from it (14).
	\begin{algorithm}[H] % enter the algorithm environment
		\caption{Counting Sort({A})} % give the algorithm a caption
		\label{alg2} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#					
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum value $k$
			\ENSURE Sorted Array
			\STATE $B \Leftarrow [1..n]$ \COMMENT{Temp array}
			\STATE $C \Leftarrow [1..k]$ \COMMENT{Count array}
			\FOR{$i\gets 1$ to $k$}
				\STATE $C \Leftarrow 0$
			\ENDFOR
			\FOR{$j\gets 1$ to $n$}
				\STATE $C[A[j]] \Leftarrow C[A[j]] + 1$ \COMMENT{Count occurence of value}
			\ENDFOR
			\FOR{$i\gets 2$ to $k$}
				\STATE $C[i] \Leftarrow C[i] + C[i-1]$\COMMENT{Accumulate Count array}
			\ENDFOR
			\FOR{$j\gets n$ to $1$ by $-1$}
				\STATE $B[C[A[j]]] \Leftarrow A[J]$ \COMMENT{Move item from input to temp array}
				\STATE $C[A[j]] \Leftarrow C[A[j]] - 1$ \COMMENT{Deincrement count array}
			\ENDFOR
			\STATE \textbf{return} $B$
		\end{algorithmic}
	\end{algorithm}	
	\pagebreak
	\subsection{Radix Sort}
	Radix sort is the method of applying the integer sorting method to each digit of the input, there are two approaches to this: Least significant digit first (LSD) or Most significant digit first (MSD).
	\subsubsection{Least Significant Digit}
	\label{ssec:lsd}
	Least Significant Digit Radix sort (LSD) takes an input array \textit{A} and sorting function \textit{f()} which can be either of the previous integer sorting methods. The input array is sorted via the chosen method once for each of digits in the chosen radix of the largest value (3) This sorting process is applied first at the least significant or rightmost digit and moves incrementally to the most significant or leftmost digit. Values can have an unequal number of digits provided any digits farther left than their most significant are taken as 0 and the chosen integer sorting method is stable as this means they maintain their relative position with respect to values that have an equal or lesser number of digits.
	
	\begin{algorithm} % enter the algorithm environment
		\caption{LSD({A, f()})} % give the algorithm a caption
		\label{alg3} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum absolute Value $k$
			\REQUIRE $f() \Leftarrow $Sorting function \COMMENT{Pigeonhole or Counting Sort}
			\ENSURE Sorted Array
			\STATE $d \Leftarrow$ Number of digits of k \COMMENT{Varies based on radix chosen}
			\STATE $A(i) \Leftarrow$ i-th digit of each item in A
			\FOR{$i\gets 1$ to $d$}
				\STATE $A \Leftarrow f(A(i))$ \COMMENT{Sorts Array using sort function}
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}
	\pagebreak
	\subsubsection{Most Significant Digit}
	Most Significant Digit Radix sort (MSD) takes an input array \textit{A}, sorting function \textit{f()} and current digit \textit{i} which for the first call of the function should be the number of digits of the largest value in the input. This algorithm operates recursively, and the termination condition occurs when \textit{i} is equal to 0 meaning that all digits of the input have been sorted (1,2). After ensuring the termination condition has not been met the input array \textit{A} is then sorted using the chosen function with respect to the current digit (5). The input array is then iterated over and items that have an equal value at the current digit are identified (8) and taken as a slice of the input array. This slice is then sorted recursively using a function call to \textit{MSD()} with a decremented value for \textit{i}  meaning they are sorted over the next least significant digit (11). Once the termination condition has been reached within this slice and all sub-slices created by recursive calls the algorithm resets the start point of the slice and identifies further slices to sort (12).
	\begin{algorithm} % enter the algorithm environment
		\caption{MSD({A, i, f()})} % give the algorithm a caption
		\label{alg4} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum absolute Value $k$
			\REQUIRE $i \Leftarrow$ Digit to sort Array on \COMMENT{start with number of digits of k}
			\REQUIRE Sorting function $f()$\COMMENT{Pigeonhole or Counting Sort}
			\ENSURE Sorted Array
			\IF{$i==0$}
				\STATE \textbf{return} $A$
			\ENDIF
			\STATE $A(i) \Leftarrow$ i-th digit of each item in A
			\STATE $A \Leftarrow f(A(i))$ \COMMENT{Sorts Array using sort function}
			\STATE $s \Leftarrow 1$ \COMMENT{Starting position of recursive call}
			\FOR{$j\gets 1$ to $s$}
				\IF{$A(i)[j] == A(i)[s]$}
					\STATE Do Nothing
				\ELSE
					\STATE $A[s..j-1] \Leftarrow MSD(A[s..j-1](i), i-1)$
					\STATE $s \Leftarrow j$ \COMMENT{Reset start position of array slice}
				\ENDIF
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}
	\pagebreak
	\section{Time complexity}
	\subsection{Integer Sorting}
	Counting and Pigeonhole sort both have a time complexity of $\mathcal{O}\textit{(n+k)}$ where \textit{n} is the number of items in the input array and \textit{k} is the maximum range of input values, this can be seen as one pass over the input data containing \textit{n} items and one pass over the intermediary buckets array for pigeonhole sort or the count array for counting sort, both of which contain \textit{k} items.
	\newline
	\subsection{Radix Sort}
	Radix sort repeatedly applies integer sorting to each successive digit of the input array, it differs from counting sort in that it does not sort into \textit{k} buckets but a constant base \textit{b} is chosen. It repeats the integer sorting method \textit{d} times where \textit{d} is the number of passes necessary to sort each digit of the maximum value in the input with respect to the base \textit{b} and can be expressed as \textit{d = $log_b$k}
	\newline
	This gives a time complexity of	$\mathcal{O}$\textit{((n + b) $\cdot$ d)} or if we select some constant value for \textit{b}; $\mathcal{O}$\textit{(n $\cdot$ d)}
	\newline However, in the application of this project, radix sort will only be applied to integers represented in 64-bits, meaning there is a defined upper bound to the max value \textit{k}. This is important because it means that that \textit{k} is polynomial in \textit{b} or that \textit{k} is always able to be represented by \textit{b} raised to some exponent \textit{c} where \textit{c} is some constant value. This can be expressed in the form \textit{k $=$ b$^{\mathcal{O}(1)}$} or \textit{$\mathcal{O}(1) = log_b$k}
	\newline
	\textit{$\mathcal{O}(1)$} can be substituted in for \textit{d} in the time complexity analysis meaning Radix sort will run in $\mathcal{O}$\textit{(n)} or linear time in the context of this project.
	\pagebreak
	\section{Radix Selection}
	
	\label{sec:radixselection}
	\subsection{Introduction}
	Radix sort utilises repeated rounds of integer sorting across each digit of the input list, therefore, it is necessary to make a clear definition of a digit so that an effective method of separating an integer into its component digits can be implemented. When expressing a number of any kind, it is necessary to establish the numerical base that will be used, this is the number of unique values that can be displayed in each digit and when a value exceeds the maximum value within this base, another digit must be added; i.e. in standard decimal or base 10 numbers 0 through 9 can be expressed in a single digit but increasing beyond this range requires adding a second digit to create the number 10.
	\newline
	Though numbers in typical day to day use by humans are typically thought of as arabic numerals in the decimal system, this is a social convention which this algorithm is not beholden to, and as Radix sort fundamentally relies on the processing of the component digits of an integer it is of great importance to select an appropriate base as well as identify an efficient method for processing each digit.
	\subsection{Explanation}
	\label{ssec:radixexplanation}
	Python stores integers in the format "two’s complement”, which is a type of binary and therefore uses a base of 2. This means that bases that are of the order $2^n$ where n is some integer are the most suitable for a typical radix sort algorithm, this is because bases that fit this specification allow each digit to be directly accessed from an integer's binary digits.
	\newline 
	Any base of $2^n$ will utilise all possible combinations of $n$ digits of binary to express a single digit and so the rightmost $n$ digits represent the first digit in $2^n$, the next $n$ digits represent the next digit etc.
	\subsection{Implementation}
 	The method of identifying each digit of an integer from the binary representation first involves manipulating the integer such that the desired digit is in the rightmost position, in base $n$ this means discarding the rightmost $n \cdot d$ binary digits where d is the index (from the right) of the required digit in base $2^n$. Following this, isolating the rightmost $n$ binary digits produces the correct digit.  
		\newline
	In order to complete this task, bitwise operations have been utilised, and are explained fully in section \ref{ssec:bitwise}.


	\begin{table}[!htb]
		\centering
		
		\vspace{0.3cm}
		\setlength{\tabcolsep}{1pt}		
        \begin{tabular}[t]{cccc}			
			\rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}		
			  &
			  \rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}
			  &
			  \rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}
			  &
			  \rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}
			  \\
			  Digit 4 & Digit 3 & Digit 2 & Digit 1 \\
			  14 & 10 & 6 & 0
			
        \end{tabular}%
		\vspace{0.1cm}
		\caption*{The 4 digits in base $2^4$ of a 16 bit integer: $60000$}

	\end{table}
	\pagebreak
	\section{Negative Integers}
	\subsection{Two's Complement}
	\label{ssec:negativestwos}
	When handling integers in two’s complement, positives are represented in binary, but with a leading 0 in the leftmost position to indicate the positive sign of the integer. Negative integers are represented with a leading 1 which represents that the binary value of this digit is to be subtracted i.e. negative and all other binary digits are positive such that the sum of all the digits equals the integer being represented. table reference has been included to illustrate this, as you can see the value $+3$ has a leading $0$ at index $2$, representing $2^{2}$ is not subtracted, this is followed by 1 in all remaining digits representing the addition of $2^{1}$ and $2^{0}$ or $2+1=3$. $\minus3$ is represented by a leading 1 to represent $\minus2^{2}$ followed by 0 1 to represent no addition of $2^{1}$ and the addition of $2^{0}$ or $\minus4 + 1 = \minus3$.
	\newline
	The effect of performing Radix sorting without any accommodation for negativity is that due to the leading 1, negative values will be incorrectly sorted ahead of positive values as though they were larger. They will also be sorted into the correct order relative to other negative values (increasing from most negative to least negative), as among values that can be represented in the same number of bits the more negative numbers have fewer additional bits in positions to the right, for example $\minus4$ is 100 and $\minus 3$ is 101.
	\newline
	The method of correcting for this problem is to invert the bits representing the sign of the largest absolute value of the input list (see \ref{sssec:xor} for further explanation). This operation causes the items to retain their relative position amongst elements of the same sign but causes negative values to be sorted to their correct position as less than positive values.
	\vspace{1cm}
	\begin{table}[!h]
	\begin{center}
		\begin{tabular}{|c c c|} 
		 \hline
		 Bits & Unsigned Value & \begin{tabular}{c}Signed Value\\(Two's Complement)\end{tabular}\\
		 \hline\hline
		 000 & 0 & 0  \\ 
		 \hline
		 001 & 1 & 1  \\
		 \hline
		 010 & 2 & 2  \\
		 \hline
		 011 & 3 & 3  \\
		 \hline
		 100 & 4 & -4  \\ 
		 \hline
		 101 & 5 & -3  \\  
		 \hline
		 101 & 6 & -2  \\ 
		 \hline
		 111 & 7 & -1  \\ 
		 \hline
		\end{tabular}
		\end{center}
		\caption{3 bit integers and their respective values when interpretted in unsigned binary and two's complement}
	\end{table}


	\pagebreak
	\subsection{Implementation}
  \label{ssec:negativesImplementation}
	The purpose of this project was to incorporate this sorting algorithm into the standard library for Pypy, meaning it had to be written in RPython, the language used for Pypy. RPython is a restricted form of python, specifically it is a form of Python 2, which is relevant to the handling of integers as RPython inherits Python2’s method of allocation of a quantity of bits for each integer equal to the word size of the machine it is being run on (typically this is 32 or 64 bits), even if the integer can be expressed in fewer bits. The leftmost bit represents whether the integer is positive or negative and the remaining bits represent the magnitude of the integer, all digits between the sign bit and the most significant bit needed to represent the integer are copies of the sign bit. To put this in the context of two’s complement , this representation can be understood as the first bit representing $\minus2^{m}$ where m is the machine word length and all following digits are additions of $2^{n}$ where n is $[m-1..0]$.
	\newline
	\newline
	The true sign bit, meaning the bit that always and exclusively represents the sign of the integer, is the one in the leftmost position, however it is not necessarily the most optimal solution to this problem of negatives being sorted into the incorrect position to flip this bit. Firstly, when sorting integers that take up a small number of bits it would require some additional logical test to identify if the algorithm is performing the first (for MSD) or last (for LSD) pass of the data to then instruct the algorithm to jump to the leftmost bit. Additionally, it is necessary to identify the machine word length of the machine on which this code is running as flipping the 64th bit on a 32 bit machine is not possible, this eliminates the possibility of a hardcoded value and essentially forces the use of the “sys.maxint” function from the Python 2 standard library. I decided that using this function was not in the best interest of this project for posterity as it was removed from Python 3 and replaced with “sys.maxsize” which means if RPython ever moved on to Python 3 this function would stop working; whilst this is a minor issue that would likely never cause problems there is an alternative solution without any issues.
	\newline
	\newline
	The approach used in this project was to identify the number of digits needed to express the largest absolute value of the input in the chosen base and then flip the leftmost bit of the digit preceding this digit. So for example the integer 246 when expressed in base 4  (equal to $2^{2}$ or 8 bits) requires 4 digits [3312], so in RPython the preceding bits are all 0 to indicate the sign being positive, this method then identifies the bits that would represent the next digit (the bits 9th and 10th from the right) and flips the leftmost digit giving it the binary value of [10] and a digit value of 2 in base 4. This dynamic approach ensures that the relative correct order within the positive and negative integers is preserved  and is suitable for use with any integers being sorted in any base.


	
	



\section{Implementation}
\subsection{Extra Methods and Class}
Explanation of all functions and classes that exist outside of the  radixsort algorithms. Each function is documented in isolation in the order they appear in the source files, for a full view of each of the files refer to {\color{red}reference}
\subsubsection{Function absolute}
The purpose of this helper method was to allow for the calculation of absolute values without overflow issues specifically caused by using the minimum possible value. This value's positive counterpart lies outside of the range of the 64 bits assigned for each integer in RPython, this causes unpredictable errors and even though there is only one specific case that necessitates the use of this method over the regular abs() inbuilt function, the runtime impacts are low so it's a worthwhile helper method to include.
\begin{lstlisting}
        import sys
        
        def absolute(num):
        if num == (-sys.maxint) - 1:
        return sys.maxint
        return -num if num < 0 else num
\end{lstlisting}
\subsubsection{Function int\textunderscore bytes}
\label{ssec:intbytes}
Returns the minimum quantity of bytes in a given radix necessary to express an integer, including a sign bit. This function is used to calculate the number of iterations that the sorting algorithm must make in order to sort all values up to and including the given input $i$.
\newline
The function calculates  $ \log_{radix}(i)$, i.e. to what power $i$ must be raised to get $radix$, uses ceil to get the next highest integer and adds $1$ to the value to allow for the sorting of negatives. It is necessary to return an integer in this case because this value is used to determine the number of bits used to identify each digit and the number of iterations over the list that must be made, both of these are discreet values. $ceil()$ has been used instead of $int()$ or $floor()$ as a value lower than needed would result in incorrect sorting of values the larger values.
\newline
\begin{lstlisting}
        from math import ceil, log
        
        def int_bytes(i, radix):
        return ceil(log(absolute(i) / log(radix))) + 1
      \end{lstlisting}
\pagebreak
\subsubsection{Function make\textunderscore radixsort\textunderscore class}
The container function that instantiates all other funtions, this is modelled on the existing function in listsort.py {\color{red}reference} to minimize compatability issues when including this project in the pypy library.
\newline
Almost all functions have been removed or altered in a major way, particularly any functions that pertain to comparative sorting, it is the general structure that has been emulated.
\begin{lstlisting}
    def make_radixsort_class(
        setitem=None,
    ):
  \end{lstlisting}
\subsubsection{Function setitem}
This function has been imported from the existing listsort.py file within rlib {\color{red} Reference? - This whole needs more research, I'm not certain it is correct}. It serves the function of enabling the input list to be edited by functions within the Radixsort class. When the $.sort()$ function is called by PyPy, it initialises the Radixsort class with the list as a constructor, this means that the list attribute is not mutable from within the class. Importing setitem $setitem$ into the class allows the input list to be updated.
\newline
This is the only existing function of the original listsort.py that was not removed.
\begin{lstlisting}
    if setitem is None:
      def setitem(list, item, value):
          list[item] = value
  \end{lstlisting}


\subsubsection{Class Radixsort}
This is the class that contains all other functions of the radixsort algorithm, it creates an object that is used to ease the manipulation of the input list and store attributes that are referenced and edited from multiple different functions.\newline in particular the list attribute contains the input list, which is used by every other funtion of the object.
\newline
The function $setitem$ is imported here as mentioned above so that the list can be edited outside of the scope of the class.
\begin{lstlisting}
        class Radixsort(object):
            def __init__(self, list, listlength=None):
                self.list = list
                self.base = 0
                self.listlength = len(self.list)
                self.radix = 0
    
            def setitem(self, item, value):
                setitem(self.list, item, value)
      \end{lstlisting}

\subsubsection{Function list\textunderscore abs\textunderscore max}
This function is an implementation of a combination of min() and max() functions (neither of which are implemented in RPython {\color{red}reference}) as well as an optional module to identify whether the list is sorted in asscending or descending order. The function also compares the maximum and minimum values and returns the value that is farthest away from $0$.
\newline
The primary purpose of this function is to return the value that is used to identify the number of passes over the input necessary for sorting, this is why it is necessary to identify the farthest value form 0 as this is the value that will contain the most digits.
\newline
The secondary purpose of the funtion is to update the class attributes $ordered$ and $reverseOrdered$, which are used to identify whether the sort function has been called on an already sorted list in which case there is no purpose in running the algorithm.
\newline
The reason that these actions are performed at the same time is because iterating over the list is necessary for both purposes, and both must be performed before sorting can take place (or not take place if the list is sorted), therefore it is more efficient to perform both tasks simultaneously.
\begin{lstlisting}
        self.ordered = True
        self.reverseOrdered = True

        def list_abs_max(self, checkorder=False):

            assert len(self.list) != 0
            m = self.list[0]
            n = self.list[0]
            prev = self.list[0]
            for i in range(1, len(self.list)):
                if self.list[i] > m:
                    m = self.list[i]
                if self.list[i] < n:
                    n = self.list[i]
                if checkorder:
                    self.ordered &= self.list[i] >= prev
                    self.reverseordered &= self.list[i] <= prev
                    prev = self.list[i]
            return m if absolute(m) > absolute(n) else n
      \end{lstlisting}
\pagebreak
\subsubsection{Function insertion\textunderscore sort}
This is an implementation of insertion sort, it is used in MSD sorts when the length of a sublist falls below the critical value. {\color{red}reference}
\begin{lstlisting}
        def insertion_sort(self, start, end):
            for step in xrange(start, end):
                key = self.list[step]
                j = step - 1
                while j >= 0 and key < self.list[j]:
                    self.setitem(j + 1, self.list[j])
                    j = j - 1
                self.setitem(j + 1, key)
      \end{lstlisting}

\subsubsection{function reverse\textunderscore slice}
This reverses the items of the input inbetween the provided start and stop indexes. By default is reverses te entire list, but includes provisions to reverse a smaller slice of the list (this was from an earlier version of the algorithm, this feature is currently unused). {\color{red}I should probably just remove that at this point}
\begin{lstlisting}
        def reverseSlice(self, start=0, stop=0):
            if stop == 0:
                stop = self.listlength - 1
            while start < stop:
                i = self.list[start]
                j = self.list[stop]
                self.setitem(start, j)
                self.setitem(stop, i)
                start += 1
                stop -= 1
      \end{lstlisting}
\pagebreak




\subsection{Bitwise operations}
\label{ssec:bitwise}
Bitwise operations operate on binary numerals at the level of individual bits, they allow for fast and consistant manipulation that bypasses arithmetic functions. Through the use of bitwise operations, radix sort can be performed using different numeral bases, meaning a diffent maximum value at each digit and a different total number of digits. By reducing the number of digits the amount of iterations over the data is reduced thereby improving run time, however this comes at the cost of an increase in the amount of time each round of integer sorting takes and an increase in the memory consumption due to the larger count list or quantity of bins. 
\newline
Bitwise operations are particular useful in this regard as it makes processing integers in bases of the order $2^n$ where $n$ is some integer very easy (see section \ref{ssec:radixexplanation}) whereas changing base from the standard base 10 requires time consuming arithmetic methods such as euclidian division.
\newline
In order to properly implement bitwise operations it was necessary to properly explore their implementation in RPython as well as the implementation of the Integer type. In RPython each integer is comprised of exactly 64 bits, where 1 bit is assigned to represent the integer's sign, leaving a maximum of 63 bits to express the magnitude of the integer, this gives integers in RPython a range of $[\minus2^{63}$ $..$ $2^{63}\minus1]$. The PyPy interpreter considers any integer outside of this range to instead be of the `Long' type, and as such a list containing even a single value outside of this range does not have the Integer specific sorting method applied to it, thus values outside of this range are not within the scope of this project.
\newline
I have already covered in general terms how these  are used in this project to identify the value of each digit in section \ref{sec:radixselection} and handle negative integers in \ref{ssec:negativesImplementation} but in this section I will cover the implementation of the bitshift operations used in RPython.
\newline

\pagebreak
\subsubsection{Left shift}\
\label{sssec:leftshift}
\newline
A `Left shift' refers to moving each bit of an integer a number of digits to the left, in RPython this is performed using: $n << s$ where $n$ is the integer to be shifted and $s$ is the number of digits the integer should be shifted to the left.
\newline
RPython utilises Arithmetic Shifting, this means when a shift is performed and the rightmost bit is no longer in the rightmost position, all digits in the range $[0 .. s]$ are overwritten with the value 0 and an equal quantity of digits in the leftmost positions are discarded.
\newline
\newline
In this project, left shifting is used to create integers that occupy a specific number of bits and is used for the accomodations necessary to sort negative integers (further explained in \ref{sssec:xor}). 
\newline

\begin{table}[htpb]
	\centering
\begin{tabular}{r|rrrrrrrr}
	
	\hline
	 Value   &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
	\hline
	 13      &   0 &   0 &   0 &   0 &   1 &   1 &   0 &   1 \\
	 13 \ensuremath{<}\ensuremath{<} 2 &   0 &   0 &   1 &   1 &   0 &   1 &   0 &   0 \\
	\hline
\end{tabular}
\caption{Demonstration of shifting 13 left 2 bits \\ only rightmost 8 bits are shown}
\end{table}

\subsubsection{Right shift}\
\label{sssec:rightshift}
\newline
A `Right shift' is the inverse of left shift, referring to moving each bit of an integer to the right, using the operator $n >> s$ where $n$ is the integer to be shifted and $s$ is the number of digits the integer should be shifted to the right.
\newline
Like Left shifting, Right shifting utilises Arithmetic shifting, meaning the rightmost $s$ digits are discarded. Right shift differs from leftshift however as the digits in the the leftmost positions that become empty are overwritten with a value equal to the most significant (leftmost) bit, which would typically represent the sign of the integer. This means that a Right shifted integer retains it's original sign.
\newline\newline
Right shifting is used in this project to manipulate integers from the input list in order to move a specific digit into the rightmost position so that the value of this digit can be extracted using Bitwise And (see \ref{sssec:and}). The bases selected for this project are of the order $2^n$ where $n$ is some integer, meaning a single digit of the integer occupies $n$ bits and therefore; Right shifting $n \cdot d$ positions places the digit $d$ from the right in the rightmost position, occupying the rightmost $n$ bits. 
\begin{table}[!htb]
	
\setlength{\tabcolsep}{4.5pt}
\begin{minipage}{.45\textwidth}
	\centering

		\begin{tabular}[t]{r|rrrrrrrr}
			\hline
			 Value   &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
			 \hline
			 13      &   0 &   0 &   0 &   0 &   1 &   1 &   0 &   1 \\
			 $13 \ensuremath{>}\ensuremath{>} 2$ &   0 &   0 &   0 &   0 &   0 &   0 &   1 &   1 \\
			 \hline
		\end{tabular}

	\caption{Shift 13 right 2 bits. Only rightmost 8 bits are shown}
	
\end{minipage}\hfill%
	\begin{minipage}{.55\textwidth}
		\centering

		\begin{tabular}[t]{r|rrrrrrrr}
			\hline
			 Value   &   63 &  62 &   61 &   60 &   59 &   58 &   57 &   56 \\
			\hline
			 -$2^{61}$      &   1 &    1 &    1 &    0 &    0 &    0 &    0 &    0 \\
			 -$2^{61} \ensuremath{>}\ensuremath{>} 2$ &    1 &    1 &    1 &    1 &    1 &    0 &    0 &    0 \\
			\hline
		\end{tabular}



		\caption{Shift $-2^{61}$ right 2 places. Only leftmost 8 bits are shown.}
		\label{table2}
	\end{minipage}\hfill%

\end{table}
\pagebreak
\subsubsection{And}\
\label{sssec:and}
\newline
The `And' operator takes two integers and compares each bit across all binary digits, returning $1$ if both bits are equal to $1$ or returning $0$ if either or both are equal to $0$.
\newline
 This is utilised in this project to isolate a specified number of bianry digits of an integer, specifically $n$ digits in binary represent one digit of the integer in base $2^{n}$. This is done by `Right shifting' $n \cdot d$ positions (as stated in \ref{sssec:rightshift}) and then by performing an `And' operation with $2^{n}\minus1$, which in binary is represented as a $1$ in the rightmost $n$ digits, and 0 in all other digits, which will retrieve the rightmost $n$ bits and 0 for all other bits.
\newline
In pypy, the And operation is performed using the  $x$ $\&$ $y$ operator resulting in an `And' operation between $x$ and $y$.
\newline

\begin{table}[htpb]
	\centering
	\begin{tabular}{r|rrrrrrrr}
		\hline
		 Value   &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
		\hline
		 59      &   0 &   0 &   1 &   1 &   1 &   0 &   1 &   1 \\
		 15      &   0 &   0 &   0 &   0 &   1 &   1 &   1 &   1 \\
		 \hline
		 59 \& 15 &   0 &   0 &   0 &   0 &   1 &   0 &   1 &   1 \\
		\hline
		\end{tabular}

	\caption{Demonstration of 'And' on 15 and 59 \\ This has isolated the rightmost 4 digits which is one digit in $2^{4}$}
\end{table}
\subsubsection{Not}\
\label{sssec:not}
\newline
The bitwise not operator produces the inverse of all binary digits in an integer, giving a 1 if an integer contains a 0 and vice versa. It is unique in the sense that it is the only operation that is performed on a solitary input. This is used in the process of inverting the sign of integers detailed in \ref{sssec:xor}


\begin{table}[htpb]
	\centering
	\begin{tabular}{r|rrrrrrrr}
		\hline
		 Value   &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
		\hline
		 102     &   0 &   1 &   1 &   0 &   0 &   1 &   1 &   0 \\
		 $\sim$102    &   1 &   0 &   0 &   1 &   1 &   0 &   0 &   1 \\
		\hline
		\end{tabular}
	\caption{Demonstration of `Not' performed on $102$ \\ All bits have been inverted}
\end{table}
\pagebreak
\subsubsection{Exclusive Or}\
\label{sssec:xor}
\newline
`Exclusive Or' compares the bits of two integers and returns a value of 1 for each digit where the two bits are different and 0 if they are the same. It is performed in pypy using $x$ $\hat{}$ $y$ which results in an `Exclusive Or' performed across all 64 bits of the two integers $x$ and $y$. 
\newline
The use case for this in this project occurs when inverting the sign bit to ensure negative and positive values are sorted correctly (see \ref{ssec:negativestwos} for details).This is done by identifying the quantity of binary digits needed to express the largest absolute value of the input using the function `int\textunderscore bytes' (shown in \ref{ssec:intbytes}) with a radix of 2, this quantity is given as the integer $d$. Left shifting an integer of value $1$ $d$ times and then subtracting 1 produces the maximum integer expressable in the same number of bits as the largest absolute input value, this is given as integer $v$. In binary $v$ contains $1$ in all digits up to the most significant digit of the largest absolute input value excluding any sign bits and a 0 in all other digits.
\newline
This value $v$ is then inverted using bitwise `Not' (see \ref{sssec:not}) so that it instead contains $0$ in the bits representing the max input and 1 in all other bits. As explained in \ref{ssec:negativesImplementation}, in two's complement binary all digits to the left of the most significant are equal and represent the sign of an integer, therefore $v$ contains $1$ in all the sign bits of the largest max input. Performing the Bitwise `Exclusive Or' operation with any value in the list against the value $v$ inverts all values in these sign bits. As shown in \ref{ssec:negativesImplementation}, negative integers are originally stored in the correct order but placed higher than positive values, performing these operations ensures that the relative order is not altered but the negatives are positioned correctly.
\newline
Depending on the base selected and the number of digits of the largest absolute value, multiple sign bits may be contained in the leftmost digit of some integers being sorted, for example $300$ contains 3 digits in base $2^4$, but only 9 digits in binary, therefore the leftmost digit includes three sign bits. Therefore all sign bits must be flipped to ensure that sorting an integer across digits containing sign bits does not alter their position in the sorted list.
\newline
\begin{table}[htpb]
	\centering
	\begin{tabular}{r|rrrrrrrr}
		\hline
		 Value     &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
		\hline
		 -13       &   1 &   1 &   1 &   1 &   0 &   0 &   1 &   1 \\
		 $\sim15$       &   1 &   1 &   1 &   1 &   0 &   0 &   0 &   0 \\
		 -13  $\hat{}$ $\sim15$ &   0 &   0 &   0 &   0 &   0 &   0 &   1 &   1 \\
		\hline
		\end{tabular}
	\caption{Performing `Exclusive Or' on $-13$ with $\sim15$ \\ All bits in range $[63 .. 8]$ now equal 0}
\end{table}


\pagebreak



\subsubsection{Optimizations {\color{red} Incomplete}}
Some of the code outlined in section {\color{red} Reference code explanation} differ in relatively substantial ways from the pseudocode outlined in section \ref{sec:design}, many of these differences arise from increasing the performance of the algorithm. In this section I will explain the function and reasoning of these differences.
\paragraph{LSD counting sort - creating all count lists in one pass}\
\newline
LSD counting sort is a combination of LSD sort (\ref{ssec:lsd}) which calls counting sort (\ref{ssec:counting}) on every digit. It iterates over the input list for each digit: once whilst counting the occurence of the values at the digit and a second time when moving the input list items into the output list based on these count lists.
\newline
An optimization I have used is to make a single pass over the input list whilst creating the count lists for every digit simultaneously instead of once for each digit. The reason this is possible is that the occurence of the values for each digit do not change based on the order of the input list, items are moved from the input list to their new position based on the value stored in the count list representing the value of the current digit of the item, the order of the input list has no bearing on the order or values of the count list. 
\newline
The values stored in the count list represent the position of the items relative to one another after being sorted across a given digit; due to MSD sort creating sublists in a specific order and then sorting the sublists' items amongst one another, a count list created for a diffent digit was therefore created for a different list and so does not represent the position of the items relative only to other items in the sublist.
\newline
The way that this has been implemented in this project is seen below. It involves creating a 2 dimensional array with an outer list of $d$ sublists each of length $r$ where $d$ is the number of digits and $r$ is the radix. Following this the input list is iterated over and for each item the count list of each digit is incremented i.e. the sublist at position $[0..d]$ represents the count of the digit at the same position. After this, list of count lists is iterated over and each list is incremented, then when moving the input items based on the count lists the relevant count list can be accesed by accessing the outer list at the index equal to the index of the current digit.\newline
	\begin{lstlisting}
		#Note: this code has been simplified
		counts = [[0 for _ in range(radix)] for _ in range(min_bytes + 1)]

		for num in self.list:
			disc = 0
			for i in xrange(min_bytes + 1):
				val = get_digit(num, i)
				counts[i][val] += 1

		for i in range(min_bytes + 1):
			for j in xrange(1, self.radix):
				counts[i][j] += counts[i][j - 1]
	\end{lstlisting}

\end{document}