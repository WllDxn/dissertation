\documentclass[12pt]{article}
\usepackage{listings}
\usepackage{color}
\usepackage{biblatex}
\bibliography{Implementation.bib}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage[a4paper, total={6in, 9.25in}]{geometry}
%opening
\usepackage{xcolor}
\usepackage[]{algorithmic, algorithm, letltxmacro}
\usepackage{eqparbox}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{array}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{hhline}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
\newlength{\commentindent}
\setlength{\commentindent}{.5\textwidth}
\makeatletter
\renewcommand{\algorithmiccomment}[1]{\unskip\hfill\makebox[\commentindent][l]{$\triangleright$~#1}\par}
\LetLtxMacro{\oldalgorithmic}{\algorithmic}
\renewcommand{\algorithmic}[1][0]{%
	\oldalgorithmic[#1]%
	\renewcommand{\ALC@com}[1]{%
		\ifnum\pdfstrcmp{##1}{default}=0\else\algorithmiccomment{##1}\fi}%
}
\newcommand{\minus}{\scalebox{0.75}[1.0]{$-$}}
\makeatother
\renewcommand\algorithmicrequire{\textbf{Input:}}
\renewcommand\algorithmicensure{\textbf{Output:}}

\setcounter{secnumdepth}{4}
\titleformat{\section}
{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\normalsize\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}
\titleformat{\paragraph}[runin]
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titleformat{\subparagraph}[runin]
{\normalfont\normalsize\bfseries}{\thesubparagraph}{1em}{}
\usepackage{collcell}
\newcolumntype{L}{>{\collectcell\lstinline}l<{\endcollectcell}}
\usepackage[font=small,skip=0pt,justification=centering]{caption}
\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
  }
\hfuzz=5.002pt 
\usepackage{url}

%%% --- The following two lines are what needs to be added --- %%%
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}
\begin{document}
{
  \hypersetup{linkcolor=black}
  \tableofcontents
}
\pagebreak
\section{Design}
\label{sec:design}
	\subsection{Pseudocode}
	This is an implementation in pseudocode of all 4 components of the radix sort variations included in this project: Radix sort starting from the most significant and least significant digit and then the integer sorting methods Counting sort and Pigeonhole sort. Each permutation of Radix sort takes the input array \textit{A} of integers and treats each item \textit{A[i]} as a series of digits d within the range 0 \textit{$\leq$ d $<$ k} where \textit{k} is the radix or the number of unique integer keys. 
	\subsubsection{Integer Sorting}
	Integer sorting is a method of sorting a list of inputs by identifying the integer key of each value of the input and using that to identify it's position in the output. Because the sorting is performed based on the integer key and not based on comparisons to other list items, it is non-comparative. Integer sorting is the underlying sorting method that is applied to each digit of the input array.
	\paragraph{Pigeonhole Sort}
	\label{ssec:pigeonhole}
	Pigeonhole sort operates by instantiating an array \textit{B} of length \textit{k} (1) containing empty arrays (3). The input array \textit{A} is iterated over and each item \textit{A[i]} is appended to the array in \textit{B} at t he position that corresponds to the current integer key of the current item. \textit{B} is then iterated over (10) and each item in each array overwrites the original array in order (11). 
	\begin{algorithm}[H] % enter the algorithm environment
		\caption{Pigeonhole Sort({A})} % give the algorithm a caption
		\label{alg1} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum value $k$
			\ENSURE Sorted Array
			\STATE $B \Leftarrow [1..k]$ \COMMENT{Buckets array}
			\FOR{$i\gets 1$ to $k$}
			\STATE $B[i] \Leftarrow [$\space$]$ \COMMENT{Each bucket contains empty array}
			\ENDFOR
			\FOR{$j\gets 1$ to $k$}
			\STATE $append$\space$ A[j]$\space$ to$\space$ B[A[j]]$ \COMMENT{Move item to bucket}
			\ENDFOR
			\STATE $c \Leftarrow 1$ \COMMENT{Insertion index of items into A}
			\FOR{$i\gets 1$ to $k$}
			\FORALL{$item$ in $B[i]$}
			\STATE $A[c] \Leftarrow item$ \COMMENT{Move items from bucket to A}
			\STATE $c \Leftarrow c + 1$		\COMMENT{Increment insertion index}
			\ENDFOR
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}

	\pagebreak
	\paragraph{Counting Sort}
	\label{ssec:counting}
	Counting sort instantiates 2 arrays; \textit{B}, the output array equal in length to the input array \textit{A} (1), and \textit{C}, a count array to store the frequency of each integer key of length \textit{k}. \textit{C} is instantiated containing only integers of value 0 (2, 4). The input array is iterated over and the integer in C at the position equal to the current integer key of the current item is incremented (7), producing a histogram of the frequency of each key. This count list is then accumulated such that each item is added to the sum of the previous items (10). Finally the input array is iterated over in reverse and each item is moved to the output array in the position that is referred to by the value expressed in the count array at the position of the current key of the current item(13), to ensure that values to not overwrite one another in the output array each item in the count array is decremented when a position in the output array is taken from it (14).
	\begin{algorithm}[H]
		\caption{Counting Sort({A})}
		\label{alg2}
		\begin{algorithmic}[1]					
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum value $k$
			\ENSURE Sorted Array
			\STATE $B \Leftarrow [1..n]$ \COMMENT{Output array}
			\STATE $C \Leftarrow [1..k]$ \COMMENT{Count array}
			\FOR{$i\gets 1$ to $k$}
				\STATE $C \Leftarrow 0$
			\ENDFOR
			\FOR{$j\gets 1$ to $n$}
				\STATE $C[A[j]] \Leftarrow C[A[j]] + 1$ \COMMENT{Count occurence of value}
			\ENDFOR
			\FOR{$i\gets 2$ to $k$}
				\STATE $C[i] \Leftarrow C[i] + C[i-1]$\COMMENT{Accumulate Count array}
			\ENDFOR
			\FOR{$j\gets n$ to $1$ by $-1$}
				\STATE $B[C[A[j]]] \Leftarrow A[J]$ \COMMENT{Move item from input to output array}
				\STATE $C[A[j]] \Leftarrow C[A[j]] - 1$ \COMMENT{Deincrement count array}
			\ENDFOR
			\STATE \textbf{return} $B$
		\end{algorithmic}
	\end{algorithm}	
	\pagebreak
	\subsubsection{Radix Sort}
	Radix sort is the method of applying the integer sorting method to each digit of the input, there are two approaches to this: Least significant digit first (LSD) or Most significant digit first (MSD).
	\paragraph{Least Significant Digit}
	\label{ssec:lsd}
	Least Significant Digit Radix sort (LSD) takes an input array \textit{A} and sorting function \textit{f()} which can be either of the previous integer sorting methods. The input array is sorted via the chosen method once for each digit in the chosen radix of the largest absolute value \textit{m} (3).
	\par 
	This sorting process is applied first at the least significant or rightmost digit and progresses incrementally to the most significant or leftmost digit. Values can have an unequal number of digits provided any digits farther left than their most significant are taken as 0.
	
	\begin{algorithm} % enter the algorithm environment
		\caption{LSD({A, f()})} % give the algorithm a caption
		\label{alg3} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum absolute Value $m$
			\REQUIRE $f() \Leftarrow $Sorting function \COMMENT{Pigeonhole or Counting Sort}
			\ENSURE Sorted Array
			\STATE $d \Leftarrow$ Number of digits of m \COMMENT{Varies based on radix chosen}
			\STATE $A(i) \Leftarrow$ i-th digit of each item in A
			\FOR{$i\gets 1$ to $d$}
				\STATE $A \Leftarrow f(A(i))$ \COMMENT{Sorts Array using sort function}
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}
	\pagebreak
	\paragraph{Most Significant Digit} \label{sssec:msdradix}
	Most Significant Digit Radix sort (MSD) takes an input array \textit{A}, sorting function \textit{f()} and current digit \textit{i} which for the first call of the function should be the number of digits of the largest value in the input. This algorithm operates recursively, and the termination condition occurs when \textit{i} is equal to 0 meaning that all digits of the input have been sorted (1,2). After ensuring the termination condition has not been met the input array \textit{A} is then sorted using the chosen function with respect to the current digit (5). 
	\par 
	The input array is then iterated over and items that have an equal integer key value at the current digit are identified (8) and taken as a slice of the input array. This slice is then sorted recursively using a function call to \textit{MSD()} with a decremented value for \textit{i} meaning they are sorted over the next least significant digit (11). Once the termination condition has been reached within this slice and all sub-slices created by recursive calls the algorithm resets the start point of the slice and identifies further slices to sort (12). Each slice on which \textit{MSD()} is called that does not meet the termination condition must wait until all sublists return, which are then placed together in \textit{A} and finally returned (15).
	\begin{algorithm} % enter the algorithm environment
		\caption{MSD({A, i, f()})} % give the algorithm a caption
		\label{alg4} % and a label for \ref{} commands later in the document
		\begin{algorithmic}[1] % enter the algorithmic environment#			
			\REQUIRE $A \Leftarrow$ Unsorted Array of length $n$ with maximum absolute Value $k$
			\REQUIRE $i \Leftarrow$ Digit to sort Array on \COMMENT{start with number of digits of k}
			\REQUIRE Sorting function $f()$\COMMENT{Pigeonhole or Counting Sort}
			\ENSURE Sorted Array
			\IF{$i==0$}
				\STATE \textbf{return} $A$
			\ENDIF
			\STATE $A(i) \Leftarrow$ i-th digit of each item in A
			\STATE $A \Leftarrow f(A(i))$ \COMMENT{Sorts Array using sort function}
			\STATE $s \Leftarrow 1$ \COMMENT{Starting position of recursive call}
			\FOR{$j\gets 1$ to $s$}
				\IF{$A(i)[j] == A(i)[s]$}
					\STATE Do Nothing
				\ELSE
					\STATE $A[s..j-1] \Leftarrow MSD(A[s..j-1](i), i-1)$
					\STATE $s \Leftarrow j$ \COMMENT{Reset start position of array slice}
				\ENDIF
			\ENDFOR
			\STATE \textbf{return} $A$
		\end{algorithmic}
	\end{algorithm}
	\pagebreak
	\subsection{Time complexity}
	\subsubsection{Integer Sorting}
	Counting and Pigeonhole sort both require one iteration over the input list which contains $n$ items and one pass over the intermediary buckets array for pigeonhole sort or the count array for counting sort, both of these arrays contain $k$ items where $k$ is the maximum range of input values. The combination of these two passes gives both integer sorting methods a time complexity of 
	\begin{table}[!h]
		\begin{center}
			\begin{tabular}{c}
				$\mathcal{O}\textit{(n+k)}$ 
			\end{tabular}				
			\end{center}
		\end{table}
	\subsubsection{Radix Sort}
	Radix sort repeatedly applies integer sorting to each successive digit of the input array, it differs from counting sort in that it does not sort into \textit{k} buckets but a constant base \textit{b} is chosen. It repeats the integer sorting method \textit{d} times where \textit{d} is the number of passes necessary to sort each digit of the maximum value in the input with respect to the base \textit{b} and can be expressed as \textit{d = $log_b$k}, giving a time complexity of:
	\begin{table}[!h]
		\begin{center}
			\begin{tabular}{c}

	 $\mathcal{O}$\textit{((n + b) $\cdot$ d)}
 \\ \\
	or if \textit{b} is a constant:
\\	\\
	$\mathcal{O}$\textit{(n $\cdot$ d)} 
			\end{tabular}
				
			\end{center}
		\end{table}
			
	However, in the application of this project, radix sort will only be applied to integers represented in 64-bits, meaning there is a defined upper bound to the max value \textit{k}. This is important because it means that that \textit{k} is polynomial in \textit{b} or that \textit{k} is always able to be represented by \textit{b} raised to some exponent \textit{c} where \textit{c} is some constant value. This can be expressed in the form \textit{k $=$ b$^{\mathcal{O}(1)}$} or \textit{$\mathcal{O}(1) = log_b$k}
	\par
	$\mathcal{O}(1)$ can be substituted in for \textit{d} in the time complexity analysis meaning Radix sort will run in $\mathcal{O}(n)$ or linear time in the context of this project.
	\pagebreak
	\subsection{Radix Selection}
	
	\label{sec:radixselection}
	Radix sort utilises multiple rounds of integer sorting across the digits of the input list, therefore, it is important to create an effective method of separating an integer into its component digits. When expressing a number, requires the selection of a numerical base, this is the number of unique values that can be displayed in each digit. When a value exceeds the maximum value within this base, another digit must be added; i.e. in standard decimal or base 10 numbers 0 through 9 can be expressed in a single digit but increasing beyond this range requires adding a second digit to create the number 10.
	\par
	Though numbers in typical day to day use by humans are typically thought of as arabic numerals in the decimal system, this is a social convention which this algorithm is not beholden to, and as Radix sort fundamentally relies on the processing of the component digits of an integer it is of great importance to select an appropriate base as well as identify an efficient method for processing each digit.
	\subsubsection{Explanation}
	\label{ssec:radixexplanation}
	Python stores integers in the format "two’s complement”, which is a type of binary and therefore uses a base of 2. This means that bases that are of the order $2^n$ where $n$ is some integer are the most suitable for this project as each single $2^n$ digit utilises a maximum of $n$ bits and each subsequent digit utilises the next $n$ bits.
	\par
	The main consideration when selecting a numerical base for Radix sort is the trade off between iterations of the integer sorting method, minimized by selecting a higher base, and speed of each iteration of integer sorting, minimized by selecting a lower base. There is technically no upper bound for $n$ when taking a theoretical approach, however in practice the constraints of a physical memory limit and larger overhead costs limit radix sort algorithm to reasonably small values of $n$. This project includes values in the range $[2..16]$ as a value of $18$ made the performance graphs seen in {\color{red}reference} unreadable for any other base due to the time taken being so much higher.
	\par 
	The reason performance suffers with a higher radix being used is that each item in the range $[1..n]$ represents a list item in the integer sorting method (count list items / buckets) and each list item requires a memory address and a certain allocation of memory when being instantiated, each list item requires access to a location in the count list/bucket list during the building stage and the count/bucket list requires iterating over when rebuilding the input list. Whilst a higher value of $n$ is desirable to reduce iterations over the input, any increase causes an exponential increase in the these overhead costs incentivising a lower $n$. 
	\par 
	The effect of larger values of $n$ being more costly is highlighted further when considering the effect of cache misses on performance. A cache is a small piece of hihg speed memory that can be accessed much faster than main memory, however this memory is much smaller than main memory and so can only store limited amounts of data. The number of successful reads of a count/bucket list item from cache can greatly improve the performance of an algorithm, and when considering radix sort, a higher $n$ value decreases the ability of the system to be stored in the cache. Lamarca and Ladner use a $n = 16$ in their implementation of radix sort to minimize cache misses and instruction count \cite{LAMARCA199966}
	\subsubsection{Implementation}
	Accessing a digit
	The method of identifying each digit of an integer from the binary representation first involves manipulating the integer such that the desired digit is in the rightmost position, in base $n$ this means discarding the rightmost $n \cdot d$ binary digits where d is the index (from the right) of the required digit in base $2^n$. Following this, isolating the rightmost $n$ binary digits produces the correct digit.  
		\par
	In order to complete this task, bitwise operations have been utilised (see \ref{ssec:bitwise}).


	\begin{table}[!htb]
		\centering
		
		\vspace{0.3cm}
		\setlength{\tabcolsep}{1pt}		
        \begin{tabular}[t]{cccc}			
			\rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}		
			  &
			  \hspace{5pt}
			  \rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}
			  &
			  \hspace{5pt}
			  \rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}
			  &
			  \hspace{5pt}
			  \rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}
			  \\
			  Digit 4 & Digit 3 & Digit 2 & Digit 1 \\
			  14 & 10 & 6 & 0
			
        \end{tabular}%
		\vspace{0.1cm}
		\caption*{The 4 digits in base $2^4$ of a 16 bit integer: $60000$}

	\end{table}
	\subsection{Negative Integers}
	\label{ssec:negativeintegers}
	\subsubsection{Two's Complement}
	\label{ssec:negativestwos}
	When handling integers in two’s complement, positives are represented in binary, but with a leading 0 in the leftmost position to indicate the positive sign of the integer. Negative integers are represented with a leading 1 which represents that the binary value of this digit is to be subtracted i.e. negative and all other binary digits are positive such that the sum of all the digits equals the integer being represented. table reference has been included to illustrate this, as you can see the value $+3$ has a leading $0$ at index $2$, representing $2^{2}$ is not subtracted, this is followed by 1 in all remaining digits representing the addition of $2^{1}$ and $2^{0}$ or $2+1=3$. $\minus3$ is represented by a leading 1 to represent $\minus2^{2}$ followed by 0 1 to represent no addition of $2^{1}$ and the addition of $2^{0}$ or $\minus4 + 1 = \minus3$.
	\par
	The effect of performing Radix sort using bitwise methods without any accommodation for negativity is that due to their leading 1, negative values will be incorrectly sorted as though they are larger than positive values. They will also be sorted into the correct order relative to other negative values (increasing from most negative to least negative), as can be seen in \hyperref[table:twoscomplement]{Table 1}, which is sorted. 	
	\par
	\subsubsection{Negatives in RPython}
  	\label{ssec:pypynegatives}
	Because the purpose of this project was to incorporate this sorting algorithm into the standard library for Pypy, it had to be written in RPython, the language used for Pypy. RPython is a restricted form of python, specifically it is a form of Python 2, which is relevant to the handling of integers as RPython inherits Python2’s method of allocation of a quantity of bits for each integer equal to the machine word size of the system  it is being run on (typically this is 32 or 64 bits), even if the integer can be expressed in fewer bits. The leftmost bit represents the sign of the integer and the remaining bits between the sign bit and the most significant bit are copies of the sign bit. To put this in the context of two’s complement, this representation can be understood as the first bit representing a value of $\minus2^{m}$ where m is the machine word length and all following digits are additions of machine where n is the index of the bit counted from the rightmost bit and in the range $[(m-1)..0]$, the sum of these values is the value of the integer.
	\par

	This project handles digits with a radix of $2^{n}$ with $n$ being some integer, and in binary representation this means each digit requires $n$ bits. This causes challenges when handling negatives as the most significant digit of integers that are made up of a number of bits not divisible by $n$ includes sign bits and integers that are made up of a number of digits divisible by $n$ do not include a sign bit.

	\subsubsection{Solution}
	The approach used in this project was to identify the number of digits needed to express the largest absolute value of the input in the chosen base and then use a bitwise exclusive or (\ref{sssec:xor}) to flip all bits to the left of it. The effect of this is that when performing a radix sort across all 64 bits of the integer list is that the order is now corrected as negative values closer to 0 retain their higher position relative to more negative values but are now always sorted below positive values.
	\par
	In order to reduce unnecessary iterations, radix sort only iterates a number of times such that the number of bits sorted across is at minimum the number of bits needed to express the absolute maximum value of the list including 1 sign bit, rounded up of course to the nearest multiple of $n$. In cases where the number of bits needed is divisible by $n$, it means the algorithm performs an addition iteration exclusively on sign bits whereas in the inverse case there is no increase in iteration count. 

	\begin{table}[!h]
		\vspace{0.5cm}
		\begin{center}
			\begin{tabular}{|c c c|} 
				\hline
				Bits & Unsigned Value & \begin{tabular}{c}Signed Value\\(Two's Complement)\end{tabular}\\
				\hline\hline
				000 & 0 & 0  \\ 
				\hline
				001 & 1 & 1  \\
				\hline
				010 & 2 & 2  \\
				\hline
				011 & 3 & 3  \\
				\hline
				100 & 4 & -4  \\ 
				\hline
				101 & 5 & -3  \\  
				\hline
				101 & 6 & -2  \\ 
				\hline
				111 & 7 & -1  \\ 
				\hline
			\end{tabular}
			\vspace{0.5cm}
			\caption{3 bit integers and their respective values when interpretted in unsigned binary and two's complement}
			\label{table:twoscomplement}
		\end{center}
	\end{table}
\pagebreak
\section{Implementation}
{\color{red} I think I should write something here}
\subsection{Extra Methods and Classes}
The algorithm relies upon a number of helper methods to operate effectively and must be contained in a specific class structure to allow for it's inclusion into PyPy. This section explains the structure of the class used and contains documentation for all of the helper methods that are used by the algorithms.

\subsubsection{Function absolute}
Allows for the calculation of absolute values without overflow issues specifically caused by using the minimum possible value. This value's positive counterpart lies outside of the range of the 64 bits assigned for each integer in RPython, this causes unpredictable errors and even though there is only one specific case that necessitates the use of this method over the regular abs() inbuilt function.
\begin{lstlisting}
	import sys
        
	def absolute(num):
        if num == (-sys.maxint) - 1:
        return sys.maxint
        return -num if num < 0 else num
\end{lstlisting}
\pagebreak
\subsubsection{Function int\textunderscore digits}
\label{ssec:intdigits}
Returns the quantity of digits needed to express an integer using a specified numerical base. Each digit requires $n$ binary bits to express an integer in the base $2^n$ excluding the sign bit which is not factored in when calculating the return value of this function but is accounted for elsewhere {\color{red} Reference}.
\par
This function repeatedly rightshifts the input value by a number of bits starting at the chosen base and increasing by the same on each repeat. This is performed until the rightshifted input is equal to $0$ or $-1$ if the input is positive or negative respectively, which indicates that the number of bits the input has been shifted by are equal to or greater than the number of bits needed to express it. The number of repeats (\textit{l}) is returned as this represents the number of digits needed to express the input value.
\par
On each repeat the current value for the rightshifted input is compared to the next value to ensure that the next value is closer to $0$, this is done because in RPython rightshifting an input by \textit{n} actually performs the input rightshifted by the \textit{n modulo s}, where \textit{s} is the machine word size. For inputs occupying a number of bits in the range $s-b < s$, the smallest value by which the input must to be shifted that exceeds or equals the number of bits of the input is greater than \textit{s}, triggering the modulo operation and thus resulting in a larger value than the previous iteration of the loop and thus the exit condition of the loop is never met. Due to these factors an exttra exit condition has been included should the next rightshifted input value be further from 0 than the current one.
\par
Intuitively it would seem the use of logarithms would be a more prudent and concise way of performing this function, as taking $\log _{r} i$ (where \textit{r} is the chosen radix) and rounding up would give the same result as this function. However the inbuilt logarithm function of RPython does not allow the base to be specified forcing the use of $\frac{\log i}{\log r}$. Implementation of this solution caused occasional floating point errors when rounding, these errors occasionally allowed an incorrect calculation of a bit mask resulting in an incorrect sort, namely when the machine word length and number of bits of the input value were divisible by the chosen base without remainder. Whilst this situation is extremely rare and it was possible to hard-code a solution for these cases, including a systematic calculation error in a function was deemed too risky.
\begin{lstlisting}
	def int_digits(i, base):
		l = 1
		v = 0 if i >= 0 else -1
		prev = i >> (l * base)
		while prev != v:
			l += 1
			new = i >> (l * base)
			if absolute(new) < absolute(prev):
				prev = i >> (l * base)
			else:
				return l
		return l
\end{lstlisting}
\pagebreak
\subsubsection{Function make\textunderscore radixsort\textunderscore class}
The container function that instantiates all other funtions, this is modelled on the existing function in listsort.py \cite{listsort} to minimize compatability issues when including this project in the pypy library.
\begin{lstlisting}
    def make_radixsort_class(
        setitem=None,
    ):
  \end{lstlisting}
\subsubsection{Functions setitem and setslice}
These functions have been imported from the existing listsort.py file within rlib \cite{listsort}. They enable the input list to be edited by functions within the Radixsort class. When the $.sort()$ function is called by PyPy, it initialises the Radixsort class with the list as a constructor, this means that the list attribute is not mutable from within the class unless these functions are imported.
\par
These are the only existing functions of the original listsort.py that were not removed.
\begin{lstlisting}
    if setitem is None:
      def setitem(list, item, value):
          list[item] = value
	
	if setslice is None:
		def setslice(list, slice, index):
			list[index : index + len(slice)] = slice
  \end{lstlisting}


\subsubsection{Class Radixsort}
This is the class that contains all other functions of the radixsort algorithm. It is initialised with the input list which is stored as an attribute for access by other functions as well as the base and radix.\par
\par
The function $setitem$ is imported here as mentioned above so that the list can be edited outside of the scope of the class.
\begin{lstlisting}
        class Radixsort(object):
            def __init__(self, list, listlength=None):
                self.list = list
                self.base = 0
                self.listlength = len(self.list)
                self.radix = 0
    
            def setitem(self, item, value):
                setitem(self.list, item, value)
				def setslice(self, slice, index=0):
					setslice(self.list, slice, index)
      \end{lstlisting}

\subsubsection{Function list\textunderscore abs\textunderscore max}
This function returns the largest absolute value of the input list as well as identifing whether the list is sorted in asscending or descending order. These functions are combined as a time saving measure as they both require a pass over the data.
\par
The primary purpose of this function is to return the value that is used to identify the number of passes over the input necessary for sorting, this is why it is necessary to identify the farthest value form 0 as this is the value that will contain the most digits. Note that neither min() or max() are implemented in RPython \cite{rpythonobj}, hence why they have not been used.
\par
The secondary purpose of the function is to identify on the first pass over the list whether it is sorted, in which case the algorithm terminates, or if it is reverse sorted in which case the list is reversed and then the algorithm terminates.
\begin{lstlisting}
        self.ordered = True
        self.reverseOrdered = True

        def list_abs_max(self, checkorder=False):
            assert len(self.list) != 0
            m = self.list[0]
            n = self.list[0]
            prev = self.list[0]
            for i in xrange(1, len(self.list)):
                if self.list[i] > m:
                    m = self.list[i]
                if self.list[i] < n:
                    n = self.list[i]
					self.ordered &= self.list[i] >= prev
					self.reverseOrdered &= self.list[i] <= prev
					prev = self.list[i]
            return m if absolute(m) > absolute(n) else n
      \end{lstlisting}
\pagebreak
\subsubsection{Function insertion\textunderscore sort}
This is an implementation of insertion sort, it is used in MSD sorts when the length of a sublist falls below the critical value. This value was determined by testing as explored  {\color{red} reference testing}
\begin{lstlisting}
        def insertion_sort(self, start, end):
            for step in xrange(start, end):
                key = self.list[step]
                j = step - 1
                while j >= 0 and key < self.list[j]:
                    self.setitem(j + 1, self.list[j])
                    j = j - 1
                self.setitem(j + 1, key)
      \end{lstlisting}

\subsubsection{Function reverse\textunderscore slice}
This reverses the items of the input inbetween the provided start and stop indexes. By default is reverses te entire list, but includes provisions to reverse a smaller slice of the list (this was from an earlier version of the algorithm, this feature is currently unused).
\begin{lstlisting}
        def reverse_slice(self, start=0, stop=0):
            if stop == 0:
                stop = self.listlength - 1
            while start < stop:
                i = self.list[start]
                j = self.list[stop]
                self.setitem(start, j)
                self.setitem(stop, i)
                start += 1
                stop -= 1
      \end{lstlisting}
\pagebreak
\subsubsection{Function is\textunderscore sorted}
This function exists to check whether a subsection of the list is sorted. It is called on subsections of the list during MSD sorts. The assert statements exist to ensure that RPython compiles the code as it does not allow for slicing lists with negative slice indexes \cite{rpythonobj}
\begin{lstlisting}
	def is_sorted(self, start=0, end=-1):
		end = end if end > -1 else self.listlength
		assert start >= 0
		assert end >= 0
		sortd, rsortd = True, True
		for i, el in enumerate(self.list[start + 1 : end]):
			if el < self.list[start + i]:
				sortd = False
				if rsortd == False:
					return sortd, rsortd
			if el > self.list[start + i]:
				rsortd = False
				if sortd == False:
					return sortd, rsortd
		return sortd, rsortd
\end{lstlisting}
\pagebreak




\subsection{Bitwise operations}
\label{ssec:bitwise}
Bitwise operations operate on binary numerals at the level of individual bits, they allow for fast and consistant manipulation that bypasses arithmetic functions. Through the use of bitwise operations, radix sort can be performed using different numeral bases, meaning a diffent maximum value at each digit and a different total number of digits. By reducing the number of digits the amount of iterations over the data is reduced thereby improving run time, however this comes at the cost of an increase in the amount of time each round of integer sorting takes and an increase in the memory consumption due to the larger count list or quantity of bins. 
\par
Bitwise operations are particularly useful in this regard as it makes processing integers in bases of the order $2^n$ where $n$ is some integer very easy (see section \ref{ssec:radixexplanation}) whereas changing base from the standard base 10 requires time consuming arithmetic methods such as euclidian division.
\par
In order to properly implement bitwise operations it was necessary to properly explore their implementation in RPython as well as the implementation of the Integer type. In RPython each integer is comprised of exactly 64 bits, where 1 bit is assigned to represent the integer's sign, leaving a maximum of 63 bits to express the magnitude of the integer, this gives integers in RPython a range of $[\minus2^{63}$ $..$ $2^{63}\minus1]$. The PyPy interpreter considers any integer outside of this range to instead be of the `Long' type, and as such a list containing even a single value outside of this range does not have the Integer specific sorting method applied to it, thus values outside of this range are not within the scope of this project.
\par
I have already covered in general terms how these  are used in this project to identify the value of each digit in section \ref{sec:radixselection} and handle negative integers in \ref{ssec:pypynegatives} but in this section I will cover the implementation of the bitshift operations used in RPython.
\subsubsection{Left shift}\
\label{sssec:leftshift}
A `Left shift' refers to moving each bit of an integer a number of digits to the left, in RPython this is performed using: $n << s$ where $n$ is the integer to be shifted and $s$ is the number of digits the integer should be shifted to the left.
\par
RPython utilises Arithmetic Shifting, this means when a shift is performed and the rightmost bit is no longer in the rightmost position, all digits in the range $[0 .. s]$ are overwritten with the value 0 and an equal quantity of digits in the leftmost positions are discarded.
\par
In this project, left shifting is used to create integers that occupy a specific number of bits and is used for the accomodations necessary to sort negative integers (further explained in \ref{sssec:xor}). 
\par

\begin{table}[htpb]
	\centering
\begin{tabular}{r|rrrrrrrr}
	
	\hline
	 Value   &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
	\hline
	 13      &   0 &   0 &   0 &   0 &   1 &   1 &   0 &   1 \\
	 13 \ensuremath{<}\ensuremath{<} 2 &   0 &   0 &   1 &   1 &   0 &   1 &   0 &   0 \\
	\hline
\end{tabular}
\caption{Demonstration of shifting 13 left 2 bits \\ only rightmost 8 bits are shown}
\end{table}
\pagebreak
\subsubsection{Right shift}\
\label{sssec:rightshift}
\par
A `Right shift' is the inverse of left shift, referring to moving each bit of an integer to the right, using the operator $n >> s$ where $n$ is the integer to be shifted and $s$ is the number of digits the integer should be shifted to the right.
\par
Like Left shifting, Right shifting utilises Arithmetic shifting, meaning the rightmost $s$ digits are discarded. Right shift differs from leftshift however as the digits in the the leftmost positions that become empty are overwritten with a value equal to the most significant (leftmost) bit, which would typically represent the sign of the integer. This means that a Right shifted integer retains it's original sign.
\par
Right shifting is used in this project to manipulate integers from the input list in order to move a specific digit into the rightmost position so that the value of this digit can be extracted using Bitwise And (see \ref{sssec:and}). The bases selected for this project are of the order $2^n$ where $n$ is some integer, meaning a single digit of the integer occupies $n$ bits and therefore; Right shifting $n \cdot d$ positions places the digit $d$ from the right in the rightmost position, occupying the rightmost $n$ bits. 
\begin{table}[!htb]
	
\setlength{\tabcolsep}{4.5pt}
\begin{minipage}{.45\textwidth}
	\centering

		\begin{tabular}[t]{r|rrrrrrrr}
			\hline
			 Value   &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
			 \hline
			 13      &   0 &   0 &   0 &   0 &   1 &   1 &   0 &   1 \\
			 $13 \ensuremath{>}\ensuremath{>} 2$ &   0 &   0 &   0 &   0 &   0 &   0 &   1 &   1 \\
			 \hline
		\end{tabular}

	\caption{Shift 13 right 2 bits. Only rightmost 8 bits are shown}
	
\end{minipage}\hfill%
	\begin{minipage}{.55\textwidth}
		\centering

		\begin{tabular}[t]{r|rrrrrrrr}
			\hline
			 Value   &   63 &  62 &   61 &   60 &   59 &   58 &   57 &   56 \\
			\hline
			 -$2^{61}$      &   1 &    1 &    1 &    0 &    0 &    0 &    0 &    0 \\
			 -$2^{61} \ensuremath{>}\ensuremath{>} 2$ &    1 &    1 &    1 &    1 &    1 &    0 &    0 &    0 \\
			\hline
		\end{tabular}



		\caption{Shift $-2^{61}$ right 2 places. Only leftmost 8 bits are shown.}
		\label{table2}
	\end{minipage}\hfill%

\end{table}
\pagebreak
\subsubsection{And}\
\label{sssec:and}
\par
The `And' operator takes two integers and compares each bit across all binary digits, returning $1$ if both bits are equal to $1$ or returning $0$ if either or both are equal to $0$.
\par
 This is utilised in this project to isolate a specified number of bianry digits of an integer, specifically $n$ digits in binary represent one digit of the integer in base $2^{n}$. This is done by `Right shifting' $n \cdot d$ positions (as stated in \ref{sssec:rightshift}) and then by performing an `And' operation with $2^{n}\minus1$, which in binary is represented as a $1$ in the rightmost $n$ digits, and 0 in all other digits, which will retrieve the rightmost $n$ bits and 0 for all other bits.
\par
In pypy, the And operation is performed using the  $x$ $\&$ $y$ operator resulting in an `And' operation between $x$ and $y$.
\par

\begin{table}[htpb]
	\centering
	\begin{tabular}{r|rrrrrrrr}
		\hline
		 Value   &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
		\hline
		 59      &   0 &   0 &   1 &   1 &   1 &   0 &   1 &   1 \\
		 15      &   0 &   0 &   0 &   0 &   1 &   1 &   1 &   1 \\
		 \hline
		 59 \& 15 &   0 &   0 &   0 &   0 &   1 &   0 &   1 &   1 \\
		\hline
		\end{tabular}

	\caption{Demonstration of 'And' on 15 and 59 \\ This has isolated the rightmost 4 digits which is one digit in $2^{4}$}
\end{table}
\subsubsection{Not}\
\label{sssec:not}
\par
The bitwise not operator produces the inverse of all binary digits in an integer, giving a 1 if an integer contains a 0 and vice versa. It is unique in the sense that it is the only operation that is performed on a solitary input. This is used in the process of inverting the sign of integers detailed in \ref{sssec:xor}


\begin{table}[htpb]
	\centering
	\begin{tabular}{r|rrrrrrrr}
		\hline
		 Value   &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
		\hline
		 102     &   0 &   1 &   1 &   0 &   0 &   1 &   1 &   0 \\
		 $\sim$102    &   1 &   0 &   0 &   1 &   1 &   0 &   0 &   1 \\
		\hline
		\end{tabular}
	\caption{Demonstration of `Not' performed on $102$ \\ All bits have been inverted}
\end{table}
\pagebreak
\subsubsection{Exclusive Or}\
\label{sssec:xor}
\par
`Exclusive Or' compares the bits of two integers and returns a value of 1 for each digit where the two bits are different and 0 if they are the same. It is performed in pypy using $x$ $\hat{}$ $y$ which results in an `Exclusive Or' performed across all 64 bits of the two integers $x$ and $y$. 
\par
The use case for this in this project occurs when inverting the sign bit to ensure negative and positive values are sorted correctly (see \ref{ssec:negativestwos} for details).This is done by identifying the quantity of binary digits needed to express the largest absolute value of the input using the function `int\textunderscore bytes' (shown in \ref{ssec:intdigits}) with a radix of 2, this quantity is given as the integer $d$. Left shifting an integer of value $1$ $d$ times and then subtracting 1 produces the maximum integer expressable in the same number of bits as the largest absolute input value, this is given as integer $v$. In binary $v$ contains $1$ in all digits up to the most significant digit of the largest absolute input value excluding any sign bits and a 0 in all other digits.
\par
This value $v$ is then inverted using bitwise `Not' (see \ref{sssec:not}) so that it instead contains $0$ in the bits representing the max input and 1 in all other bits. As explained in \ref{ssec:pypynegatives}, in two's complement binary all digits to the left of the most significant are equal and represent the sign of an integer, therefore $v$ contains $1$ in all the sign bits of the largest max input. Performing the Bitwise `Exclusive Or' operation with any value in the list against the value $v$ inverts all values in these sign bits. As shown in \ref{ssec:pypynegatives}, negative integers are originally stored in the correct order but placed higher than positive values, performing these operations ensures that the relative order is not altered but the negatives are positioned correctly.
\par
Depending on the base selected and the number of digits of the largest absolute value, multiple sign bits may be contained in the leftmost digit of some integers being sorted, for example $300$ contains 3 digits in base $2^4$, but only 9 digits in binary, therefore the leftmost digit includes three sign bits. Therefore all sign bits must be flipped to ensure that sorting an integer across digits containing sign bits does not alter their position in the sorted list.
\par
\begin{table}[htpb]
	\centering
	\begin{tabular}{r|rrrrrrrr}
		\hline
		 Value     &   7 &   6 &   5 &   4 &   3 &   2 &   1 &   0 \\
		\hline
		 -13       &   1 &   1 &   1 &   1 &   0 &   0 &   1 &   1 \\
		 $\sim15$       &   1 &   1 &   1 &   1 &   0 &   0 &   0 &   0 \\
		 -13  $\hat{}$ $\sim15$ &   0 &   0 &   0 &   0 &   0 &   0 &   1 &   1 \\
		\hline
		\end{tabular}
	\caption{Performing `Exclusive Or' on $-13$ with $\sim15$ \\ All bits in range $[63 .. 8]$ now equal 0}
\end{table}


\pagebreak
\subsection{Optimizations}
Many of the algorithms developed for this project differ in substantial ways from the pseudocode outlined in section \ref{sec:design}, these differences arise from increasing the performance of the algorithm or adapting them to the purpose of implementation in RPython. In this section I will explain the function and reasoning of these differences.
\subsubsection{Streamlining count lists}
\label{sssec:countlist}
LSD counting sort involves sorting from the least to most significant digit (\ref{ssec:lsd}) using counting sort (\ref{ssec:counting}). This implies iterating twice over the input list for each digit: first whilst counting the occurence of the values at the digit and a second time when moving the input list items into the output list.
\par
A suggestion by Friend \cite{Friend} is to combine the counting and moving operations into the same iteration over the input list. This is possible because the relative position of list items does not influence the frequency of the integer keys at each digit, the count list would be idendical bo matter the order of the list.
\par
The effect this has is that it reduces the number of iterations needed to complete radix sort by half, though 1 initial extra iteration is needed to establish the first count list. Though this requires an extra $2^n$ space to store the additional count list.
\par 
In terms of implementation, an initial pass over the data counts the occurance of each integer key at the least significant digit, then the algorithms begins a loop over the remaining digits. The first task is the accumulation of the count list, then the input list is iterated over, where the key value at the current digit is used to identify the position of each item in the output list and the next digit it used to create a second count list. Before the next digit is examined, the count list must be overwritten with the second count list, all items of which can be set to 0 during the accumulation stage.
\begin{table}[H]
	\centering
\begin{lstlisting}
	count = [0 for _ in xrange(self.radix)]; nextcount = count[:]
	for j in xrange(self.list_length):
		masked_input = self.list[j] ^ bit_mask
		curr_digit = (masked_input) & (self.radix - 1)
		count[curr_digit] += 1
	for i in xrange(list_max_digits):
		for j in xrange(1, self.radix):                    
			count[j] += count[j - 1]
			nextcount[j] = 0
		nextcount[0] = 0

		count[curr_digit] -= 1
		if i < list_max_digits-1:
			nextcount[next_curr_digit] += 1
\end{lstlisting}
\caption*{Count list accumulation using two count lists \\ This code is simplified, see \ref{sssec:lsdcounting}}
\end{table}

	\subsubsection{Order checking}
	\label{sssec:order}
	{\color{red} This needs testing further, it might be incorrect}
	\par
Radix sort has no advantage when called on already sorted lists compared to unsorted due to the non-comparative nature of the algorithm. Simple comparative algorithms such as bubble sort will out perform radix sort when called on sorted lists and as Timsort is highly efficient at sorting them there is substantial motivation for improvements to be made with regards to handling sorted data.
\par
Identifying sorted lists is not computationally expensive, it involves iterating over and comparing the list items in order and ensuring that each value is larger or equal to the previous value, essentially only involving $n\minus1$ comparisons where $n$ is the input list length giving a time complexity of $\mathcal{O}(n)$. As this algorithm already involves iterating over the data, the run time cost of adding a comparison function to check for sortedness is extremely low, thus a check to identify whether a list is sorted as well as whether a list is reverse sorted is included in the first iteration over the data, which is the point at which the absolute maximum value of the list is identified (a necessary step for this algorithm).
\begin{table}[H]
	\centering
	\begin{lstlisting}
		def list_abs_max(self, checkorder=False):
	
		m = self.list[0]
		n = self.list[0]
		prev = self.list[0]
		(ordered, reverseordered) = (True, True)
		for i in range(1, len(self.list)):
			ordered &= self.list[i] >= prev
			reverseordered &= self.list[i] <= prev
			prev = self.list[i]
		if checkorder:
			self.ordered = ordered
			self.reverseOrdered = reverseordered
	\end{lstlisting}
	\caption*{Checking whether the list is ordered or reverse ordered whilst\\ iterating over the list to identify the absolute maximum value}
\end{table}
\par
An extension of this idea is to perform this order checking every time the input list is rearranged (once for each digit). Unlike the initial order checking which has a minor footprint on the run time of the algorithm, checking order on each digit has a moderately significant impact, therefore it should only be implemented on the conditions that it reasonably likely that sorted lists will occur and that when the test does identify a sorted list the time saved from early termination of the algorithm is greater than the time added by performing the test. 
\par
Testing involving the comparison of the performance of algorithms including and excluding order checking showed that MSD radix sorts can benefit from order checking performed on sublists which trigger positive ordered tests frequently and early termination of the sorting of these sublists improved performance {\color{red} Reference testing that proves this}. In contrast, LSD sorts rarely trigger positive results with the frequency of these events dropping to 0 when negative integers are included. The lack of occurences of sorted lists in this circumstance is likely because the least significant digits have weaker influence on the size of integers meaning aside from random events and specific circumstances the input list is simply less likely to become sorted earlier than expected; the inclusion of negatives procludes the possibility of a list being sorted because of the leading sign bits causing negatives (and particularly negatives closer to 0) to be sorted as though they are the largest integers i.e. in the wrong order. 
\par
\begin{table}[H]
	\centering
	\begin{lstlisting}
        def is_sorted(self, start=0, end=-1):
            end = end if end > -1 else self.listlength
            assert start >= 0; assert end >= 0
            sortd, rsortd = True, True
            for i, el in enumerate(self.list[start + 1 : end]):
                if el < self.list[start + i]:
                    sortd = False
                    if rsortd == False: return sortd, rsortd
                if el > self.list[start + i]:
                    rsortd = False
                    if sortd == False: return sortd, rsortd
            return sortd, rsortd
	\end{lstlisting}
	\caption*{Checking whether a slice of the list is ordered or reverse ordered \\after integer sorting has been applied to each digit}
\end{table}
\par

\pagebreak
\subsubsection{Skipping iterations}
\label{sssec:skip}
The time complexity of radix sort is $\mathcal{O}${($N \cdot k$)} where k is the number of digits that must be sorted, therefore it is possible (and effective) to have a meaningful effect on the runtime of the algothim by reducing k, this is why the use of different bases has been focussed on as this also reduces k (the number of iterations over the input list that needs to be made).
\par
Skipping iterations over the data can be made by identifying digits on which no sorting is necessary, the specific method of identification differs based on the implementation of radix sort.
\par
For counting sort, if every single list item contain an identical value for a digit there will be no change in the order of the list when sorting across that digit. This circumstance is identified by a single count list item being equal to the list length and can be identified by iterating over the count list, a positive result means the process of moving the list items can be skipped. As the count list is already iterated over to accumulate the values, this test is computationally inexpensive.
\begin{table}[H]
	\centering
	\begin{lstlisting}
		skip = []
		for i in xrange(min_bytes):
			for j in xrange(self.radix):
				if counts[i][j] == self.listlength:
					skip.append(i)
					break
				if j==1: continue
				counts[i][j] += counts[i][j - 1]
	\end{lstlisting}
	\caption*{Identifying if all items have an identical value for each digit in LSD counting sort. \\ The same process is used for MSD counting sort but the sublist length is used instead of total list length}
\end{table}
\par
In pigeonhole sort a similar opportunity arises in the form of identifying whether all items have been placed into any of the buckets which would mean overwriting the input list with the bucket wouldn't change the order. Testing for this condition involves iterating over the buckets list and counting the number of non-empty buckets, if the count increases past 1 bucket it signals the condition has not been met and the test iteration can be terminated. This test takes up no space and at worst $\mathcal{O}${($k$)} time to iterate over the bucket list but negative resulting tests take far less time typically.

\begin{table}[H]
	\centering
	\begin{lstlisting}
		count = 0
		for b in bucket:
			if b!=[]:
				count+=1
				if count>1:
					break
		if count==1:continue
	\end{lstlisting}
	\caption*{Identifying if more than 1 bucket has been used}
\end{table}


\subsubsection{Insertion sort}
Radix sort has a significant overhead cost due to the establishment of the count lists and the list of bins that must be instantiated or cleared on each digit, this cost has little to no relation to the length of the list and so it is oveten highly inefficient when compared to other algorithms to perform radix sort.
\par
This issue beomes exponentially worse when radix sort is implemented in MSD fashion due to the nature of establishing sub-lists and thus performing sorting on an ever increasing number of lists containing progressively fewer and fewer items (sorting $150000$ items in base $2^{16}$ can create over $65000$ lists with an average length of $2$ for which the count list must be established separately).
\par
Using insertion sort in situations where the input list is reasonably small can be much more efficient than performing continuous rounds of radix sort, this effect is compounded on small lists of large items. Identifying the exact point at which it becomes more efficient to use insertion sort was done by testing the time taken to sort lists containing an increasing number of items by the MSD radix sort methods compared to insertion sort. Starting at 2 items where insertion sort universally out-performs each sorting method, an increase in the initial list length by 1 item is tested repeatedly and eventually all radix sort methods perform better than insertion sort above a certain list length with is different for pigeonhole sort and counting sort and different for each numerical base used. The value of list length at which each sorting method out-performs insertion sort is taken as the critical value. 
\begin{table}[H]
	\centering
	\begin{lstlisting}
        def insertion_sort(self, start, end):
            for step in xrange(start, end):
                key = self.list[step]
                j = step - 1
                while j >= 0 and key < self.list[j]:
                    self.setitem(j + 1, self.list[j])
                    j = j - 1
                self.setitem(j + 1, key)
	\end{lstlisting}
	\caption*{Insertion sort algorithm used in this project}
\end{table}

\pagebreak
\subsection{Algorithms}
\label{ssec:algorithms}
\subsubsection{Shared Variables}
At the start of each algorithm the following variables are instantiated, they are integral to the a correct radix sort and are identical across all implementations.
\begin{description}
	\item[listmax]contains the largest absolute value of the list and is used to calculate the passes over the data needed to complete sorting as well as the bitmask used to invert the sign bit.
 	\item[list\textunderscore max\textunderscore digits] Represents the total number of iterations over the data (rounds of integer sorting) that wil be needed. This is calculated by calling the function \textbf{\textit{int\textunderscore bytes()}} (\ref{ssec:intdigits}) with \textbf{list\textunderscore max} and the selected base.
	\par
	Ensuring that this algorithm properly sorts integers with respect to their sign requires that the most significant digit sorted includes at least one sign bit (see \ref{ssec:pypynegatives}). Identifying if this is the case involves observing whether the quantity of bits needed to express \textbf{list\textunderscore max} is divisible by the selected base with or without a remainder.
	\par 
	If there is a remainder then the leftmost digit of \textbf{list\textunderscore max}, when expressed in the selected radix ($2^{base}$), includes at least 1 sign bit and thus all negative/positive integers will be properly sorted when this digit is iterated over.
	\par
	If there is no remainder then the sign bit is not included in the leftmost digit of \textbf{list\textunderscore max} as all bits in the leftmost digit are needed to express the magnitude of the digit. This signals that an extra iteration needs to be added to ensure negative values are properly sorted.
	\par
	This extra iteration does not get added on if the quantity of digits in binary of \textbf{list\textunderscore max} and the system maximum integer are equal as this would result in a rightshift of more bits than there are in an integer resulting in an error in RPython {\color{red}go into detail? it's kind of pointless}. In this case the additional pass is not needed anyway as the leftmost bit is always the sign bit and so will definititely be included in sorting.
	\par
	\begin{table}[!htb]
		\caption*{Below are two integers expressed in binary, the sign bits are highlighted and the binary digits are split into groups of 4 illustrating the number of iterations that would be needed if they were the maximum absolute value of an input list}
		\vspace{5pt}
		\setlength{\tabcolsep}{10pt}
		\begin{minipage}{.45\textwidth}
		\centering		
		
		\vspace{10pt}
		\caption*{174}
		\vspace{10pt}

		\setlength{\tabcolsep}{1pt}		
        \begin{tabular}[t]{cccc}			
			\rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}

					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}
			  &
			  \hspace{10pt}
			  &
			  \rotatebox{90}{\begin{math}
				\left\{
				  \begin{array}{l}
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}\\
					\rotatebox[origin=c]{-90}{1}\\ 
					\rotatebox[origin=c]{-90}{0}\\
					\vspace{0mm}\\					
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{1}\\
					\rotatebox[origin=c]{-90}{0}
				  \end{array}
				\right.
			  \end{math}}

			  \\
			  Sign bits & &Significant digits  \\
			
        \end{tabular}%
		\vspace{0.1cm}
		\caption*{This integer occupies 8 bits or 2 digits in base $2^4$, but as there is no sign bit in the most significant digit, \textbf{3} iterations are necessary for sorting}
			
		\end{minipage}\hfill%
			\begin{minipage}{.45\textwidth}
				\centering	
				\vspace{10pt}	
				\caption*{26}
				\vspace{10pt}
				\setlength{\tabcolsep}{1pt}		
				\begin{tabular}[t]{cccc}			
					\rotatebox{90}{\begin{math}
						\left\{
						  \begin{array}{l}
		
							\rotatebox[origin=c]{-90}{0}\\
							\rotatebox[origin=c]{-90}{0}\\
							\rotatebox[origin=c]{-90}{0}\\
							\rotatebox[origin=c]{-90}{0}\\
							\vspace{0mm}\\
							\rotatebox[origin=c]{-90}{0}\\
							\rotatebox[origin=c]{-90}{0}\\
							\rotatebox[origin=c]{-90}{0}
						  \end{array}
						\right.
					  \end{math}}
					  &
					  \rotatebox{90}{\begin{math}
						\left\{
						  \begin{array}{l}

 
							\rotatebox[origin=c]{-90}{1}\\
							\vspace{0mm}\\					
							\rotatebox[origin=c]{-90}{1}\\
							\rotatebox[origin=c]{-90}{0}\\
							\rotatebox[origin=c]{-90}{1}\\
							\rotatebox[origin=c]{-90}{0}
						  \end{array}
						\right.
					  \end{math}}
		
					  \\
					  Sign bits & Significant digits  \\
					
				\end{tabular}%
				\vspace{0.1cm}
				\caption*{This integer occupies 5 bits or 2 digits in base $2^4$, and as there is at least 1 sign bit in the most significant digit only \textbf{2} iterations are needed}
			\end{minipage}\hfill%
		
		\end{table}

		\item[bit\textunderscore mask] A bitmask used to invert the sign of the inputs. In binary this value is represented by 0 in all digits needed to express \textbf{list\textunderscore max} in two's complement excluding the sign bit and a 1 in all other digits. This is calculated using an integer, $1$, lefshifted a by a value equal to the quantity of digits in binary of \textbf{list\textunderscore max} minus 1 (to account for 1 already containing a digit). Subtracting 1 from this value produces an integer that, represented in binary, contains a 1 in all digits needed to express \textbf{list\textunderscore max} and 0 in every digit to the left. Thus the inverse of this value, calculated by bitwise not (\ref{sssec:not}), can be used in conjuction with a bitwise exclusive or operation (\ref{sssec:xor}) to invert the sign bit and all digits to the left without altering the magnitude of the input value.
	\end{description}
	\begin{table}[H]
		\lstset{
			language=python,
		numbers=left,
		stepnumber=1,
		showstringspaces=false,
		tabsize=3,
		breaklines=true,
		breakatwhitespace=false,}
		\centering
		\begin{lstlisting}[escapeinside={(*}{*)}]
		def sort(self):
			if self.list_length < 2:
				return
			list_max = self.list_abs_max()
			list_max_digits = int_digits(list_max, self.base)
			if self.ordered:
				return
			if self.reverse_ordered:
				self.reverse_slice()
				return
			max_bits = int(int_digits(list_max, 1))
			bit_mask = (*$\sim$*)((1 << max_bits) - 1)
			if max_bits % self.base == 0 and max_bits != int_digits(
				(-sys.maxint) - 1, 1
			):
				list_max_digits += 1
		\end{lstlisting}
		\caption*{Shared variables}
		\end{table}

	\subsubsection{LSD Counting sort}
	\label{sssec:lsdcounting}
	This algorithm sorts from least to most significant digit, performing \textit{counting sort} on each digit but differs from \ref{ssec:counting} as the method is split into the counting and moving processes to reduce iterations over the input list (see \ref{sssec:countlist})
	\begin{description}
		\item[Counting integer keys] A 2-dimensional list is instantiated, equal in length to \textbf{list\textunderscore max\textunderscore digits} (the number of digits needed to express \textbf{list\textunderscore max} in the selected numerical base) where each item is a list equal in length to the radix (the number of possible unique keys for each digit), filled with the integer $0$. 
		\par The second level of lists store the frequency of occurence of each possible integer key for each item in the input list across a single digit with the first item in the list storing the rightmost/least significant digit.
		\par The 2 dimensional nature of this list \textit{counts} allows it to store the frequency of each possible integer key at each digit of the input list, meaning the input list needs only be iterated over once to complete the counting process (as stated in \ref{sssec:countlist}).
	\item[Count list accumulation] The counts lists are accumulated, such that the value at each index becomes the sum of all values from 0 up to the index. Before this, each count item is compared to the input list length as the two values being equal indicates sorting is not needed at this digit so the digit index is added to the skip list (see \ref{sssec:skip})
	\item[Performing sorting] Finally the items are sorted based on the values in the count lists, but this operation rquires $\mathcal{O}(n)$ extra space, so \textit{temp\textunderscore list} is instantiated as a copy of the input list. After sorting the list across a digit into the temp list, the \textit{setslice} method is applied, overwriting the entire input list.
\end{description}
\begin{table}[H]
	\lstset{
		language=python,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=3,
    breaklines=true,
    breakatwhitespace=false,}
	\centering
	\begin{lstlisting}[escapeinside={(*}{*)}]
	def sort(self):
		#Shared variables		
		counts = [[0 for _ in xrange(self.radix)] for _ in xrange(list_max_digits)]
		for j in xrange(self.list_length):
			masked_input = self.list[j] ^ bit_mask
			for i in xrange(list_max_digits):
				shift = (self.base) * i
				curr_digit = ((masked_input >> shift)) & self.radix - 1
				counts[i][curr_digit] += 1

		skip = []
		for i in xrange(list_max_digits):
			for j in xrange(1, self.radix):
				if counts[i][j] == self.list_length:
					skip.append(i)
				counts[i][j] += counts[i][j - 1]
		temp_list = self.list[:]

		for i in xrange(list_max_digits):
			if i in skip:
				continue
			shift = (self.base) * i
			for j in xrange(self.list_length - 1, -1, -1):
				masked_input = (self.list[j]) ^ bit_mask
				curr_digit = ((masked_input >> shift)) & self.radix - 1
				temp_list[counts[i][curr_digit] - 1] = self.list[j]
				counts[i][curr_digit] -= 1
			self.setslice(temp_list)
	\end{lstlisting}
	\caption*{LSD counting sort}
\end{table}
\pagebreak
\subsubsection{LSD Pigeonhole sort}
\begin{description}
	\item[bucket\textunderscore list] This two dimensional list contains a quanity of empty lists equal to the radix. Input list items are moved into the bucket with the index equal to the value of the digit at a given position.\par Because the frequency of each digit is not known, the sublists must be instantiated empty and the append method is used to insert list items.
	\item[skip iteration check] After moving the list items into the buckets, a list comprehension is used to count the number of non empty buckets (line 27). If this value is $1$ this indicates that the list order will not change by unpacking he buckets to overwrite the input list and so the bucket containing the single non empty list is overwritten with an empty list and the next digit is processed.
	\item[Overwriting the input list] The bucket list is iterated over and any on empty buckets are used to overwrite the input list before being themselves overwritten with an empty list. The list length of the buckets is accumulated and used as the start index of the \textit{setslice} method at this refers to the number of inputs already overwritten.
\end{description}

\begin{table}[H]
	\lstset{
		language=python,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=3,
    breaklines=true,
    breakatwhitespace=false,}
	\centering
	\begin{lstlisting}[escapeinside={(*}{*)}]
	def sort(self):
		#Shared variables
		bucket_list = [[] for _ in xrange(self.radix)]

		for i in xrange(list_max_digits):
			shift = (self.base) * i
			for num in self.list:
				masked_input = num ^ bit_mask
				curr_digit = ((masked_input >> shift)) & self.radix - 1
				bucket_list[curr_digit].append(num)
			nonempty = [
				(bdx, bucket)
				for bdx, bucket in enumerate(bucket_list)
				if bucket != []
			]
			if len(nonempty) == 1:
				bucket_list[nonempty[0][0]] = []
				continue
			index = 0
			for bdx, bucket in enumerate(bucket_list):
				if len(bucket) == 0: continue
				self.setslice(bucket, index)
				index += len(bucket)
				bucket_list[bdx] = []
\end{lstlisting}
\caption*{LSD pigeonhole sort}
\end{table}
\pagebreak
\subsubsection{MSD Counting sort}
MSD Radix sort as outlined in \ref{sssec:msdradix} sort operates by using integer sorting on each digit to divide the input list into sublists upon which a recursive call to MSD Radix sort is made to sort across the next digit of each sublist.
\par In order to avoid recursive calls {\color{red} Why?}, this project implements a method of storing only the start and end index of the sublists then iterating over this list of indexes when sorting over the next digit and sorting items within each index range only amongst eachother.
\begin{description}
	\item[Sublist Indexes] 
	\par 
	This requires two index lists, the first is instantiated on line 4, and contains the indexes 0 and list\textunderscore length, meaning the first sublist contains every item within the input list. The second is \textit{temp\textunderscore sublist\textunderscore indexes} on line 7 which is instantiated as empty at the beging of the process of applying integer sorting to each digit.
	\par
	The algorithm iterates over the digits starting at \textit{list\textunderscore max\textunderscore digit} down to 0, meaning the most to least significant. For each digit the sublist indexes are iterated over and for every pair of indexes, the integer sorting method counting sort is applied. When the count list is being accumulated, any items containing a count value greater than 1 indicates that a new sublist must be created, it's start index is calculated by taking the start index of the current sublist added to the previous entry in the accumulated count list i.e. the total number of items within the sublist that preceed the new sublist and the end index is the start index added to the total number of items with the current integer key i.e. the number of items within the new sublist.
	\par The indexes of the new sublists are appended to \textit{list\textunderscore max\textunderscore digit}, meaning all of the sublist indexes for the next digit are calculated whilst a digit is being sorted and not that a sublist is sorted immediately after being identified as could be expected with a typical recursive implementation. At the end of the iteration over all \textit{sublist\textunderscore indexes} items, it is overwritten by \textit{list\textunderscore max\textunderscore digit} which is then overwritten as empty on the next iteration of the digits.
	\par When a sublist does not require sorting, it's indexes are not included in the sublist index list, this occurs when \textit{slice\textunderscore sorted} returns positive for sorted or reverse sorted, when \textit{insertion\textunderscore sort} is used or when a sublist contains only 1 item and this just means these items will no longer be included in the sorting of any subsequent digits. A sublist that has all items sorted into the same integer key simply has it's start and end index added to \textit{temp\textunderscore sublist\textunderscore indexes} for sorting on the next digit.

	\item[Sorted Sublists] \textit{slice\textunderscore sorted} is used to identify if sublists are sorted, which happens increasingly frequently on smaller sublists, this improves performance somewhat {\color{red}Reference}
	\item[Insertion sort] The limit on line 15 is different for all bases and was identified using the method seen in {\color{red} Reference}
\end{description}
\begin{table}[H]
	\lstset{
		language=python,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=3,
    breaklines=true,
    breakatwhitespace=false,}
	\centering
	\begin{lstlisting}[escapeinside={(*}{*)}]
        def sort(self):
			#Shared variables
			count = [0 for _ in xrange(self.radix)]
			sublist_indexes = [(0, self.list_length)]
			for k in xrange(list_max_digits - 1, -1, -1):
				shift = k * self.base
				temp_sublist_indexes = []
				for start, end in sublist_indexes:
					if start + 1 == end: continue
					sublist_sorted, sublist_reverse_sorted = self.slice_sorted(start, end)
					if sublist_sorted: continue
					if sublist_reverse_sorted:
						self.reverse_slice(start, end - 1)
						continue
					if (end - start) < (*\textit{\color{red}Limit}*):
						self.insertion_sort(start, end)
						continue
					for idx in xrange(start, end):
						masked_input = (self.list[idx]) ^ bit_mask
						curr_digit = ((masked_input >> shift)) & self.radix - 1
						count[curr_digit] += 1
					if count[-1] == end - start:
						temp_sublist_indexes.append((start, end))
						count = [0 for _ in count]
						continue
					if count[0] > 1:
						temp_sublist_indexes.append((start, start + count[0]))
					for i in xrange(1, self.radix):
						if count[i] > 1:
							temp_sublist_indexes.append(
								(start + count[i-1], start + count[i] + count[i-1])
							)
						count[i] += count[i - 1]
					temp_list = [0 for _ in range(start, end)]
					for i in xrange(start, end):
						masked_input = (self.list[i]) ^ bit_mask
						curr_digit = ((masked_input >> shift)) & self.radix - 1
						temp_list[count[curr_digit] - 1] = self.list[i]
						count[curr_digit] -= 1
					count = [0 for _ in count]
					self.setslice(temp_list, start)
				sublist_indexes = list(temp_sublist_indexes)
				if not sublist_indexes: return
\end{lstlisting}
\caption*{MSD Counting sort}
\end{table}


\subsubsection{MSD Pigeonhole sort}
Once again, the method of storing indexes of sublists and sorting within the index ranges is applied.
\begin{description}
	\item[Sublist Indexes] This works in largely the same way as MSD Counting sort, sublist indexes are iterated over and items in a sublist have the integer sorting method, pigeonhole sort applied to them wherein further sublist indexes are identified and added to \textit{temp\textunderscore sublist\textunderscore indexes} to be sorted on the next iteration over the digits.
	\par To calculate the indexes when sorting a sublist, first a cumulative value is instantiated at 0 (\textit{index}, line 31). The buckets are then iterated over, non empty bucket is considered a sublist with the stating index equal to the start index of the current sublist added to \textit{index} with the same for the end index plus the list length of the bucket. The list length of the bucket is added to the cumulative value \textit{index} so that it contains the total quantity of items in all buckets iterated over thus far. This occurs during the loop that overwrites the input list with the buckets as well as clearing the bucket list so it contains only empty lists.
	\item[Insertion sort] The threshold used for insertion sort is different for each base, and is different from those used for counting sort, see {\color{red} reference}.
	\item[Bucket List] To avoid repeated instantiation of \textit{bucket\textunderscore list}, it is created once at the same stage as the shared variables as a list of empty lists with a length equal to the radix. Instead of creating the bucket list again multiple times, each bucket is only overwritten with an empty bucket if it is accessed and identified as non empty, this saves on the number of read/write calls.
\end{description}
\begin{table}[H]
	\lstset{
		language=python,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=3,
    breaklines=true,
    breakatwhitespace=false,}
	\centering
	\begin{lstlisting}[escapeinside={(*}{*)}]
	def sort(self):
		#Shared variables
		sublist_indexes = [(0, self.list_length)]
		bucket_list = [[] for _ in xrange(self.radix)]
		for k in xrange(list_max_digits - 1, -1, -1):
			shift = k * self.base
			temp_indexes = []
			for start, end in sublist_indexes:
				if start + 1 == end:continue
				sublist_sorted, sublist_reverse_sorted = self.slice_sorted(					start, end )
				if sublist_sorted: continue
				if sublist_reverse_sorted:
					self.reverse_slice(start, end - 1)
					continue
				if (end - start) < (*\textit{\color{red}Limit}*):
					self.insertion_sort(start, end)
					continue
				for i in xrange(start, end):
					masked_input = (self.list[i]) ^ bit_mask
					curr_digit = ((masked_input >> shift)) & self.radix - 1
					bucket_list[curr_digit].append(self.list[i])
				nonempty = [
					(bdx, bucket)
					for (bdx, bucket) in enumerate(bucket_list)
					if bucket != []
				]
				if len(nonempty) == 1:
					temp_indexes.append((start, end))
					bucket_list[nonempty[0][0]] = []
					continue
				index = 0
				for bdx, bucket in enumerate(bucket_list):
					if len(bucket) >= 1:
						temp_indexes.append(
							(start + index, start + index + len(bucket))
						)
						self.setslice(bucket, start + index)
						index += len(bucket)
						bucket_list[bdx] = []
			sublist_indexes = temp_indexes
			if not sublist_indexes: return
\end{lstlisting}
\caption*{MSD Pigeonhole sort}
\end{table}
\pagebreak
\section{Testing}
\subsection{Test Criteria}
\subsubsection{Using PyPy for testing}
When testing the algorithms designed for this project, it was necessary to design tests with the core project goal in mind, to design a more efficient integer sorting method for use within PyPy. It is therefore a criteria of primary importance that tests be performed on a version of PyPy that has been compiled with a custom sorting method that implements the algorithms designed as part of this project. 
\par 
Testing with this criteria in mind, and testing continuously throughout the development process, ensured that any solutions produced were applicable to the goals of the project and ventures into solutions that may work on other platforms such as Python 3 or even Python 2 but not on RPython were short lived. For example an early solution of this project utilised the inbuilt methods \textit{max()} and \textit{min()}, which are not available in RPython at a later stage the stark difference in RPython handling rightshifting by values greater than the machine word size as the value moldulo the machine word size whereas in all other versions of Python the full rightshift is performed, giving very diffent results to the helper method outlined in \ref{ssec:intdigits}.
\par 
PyPy source code includes the file \textit{rpython} used to compile and package PyPy, this file has the useful feature of allowing the compilation of a single file into an executable, which is helpful as compiling a single file takes less than 30 seconds wheras compiling a fully functioning version of PyPy can tak up to 20 minutes. This feature was regularly utilised during the development process to test the correctness of solutions but is not particularly useful when testing performance for a number of reasons. Firstly it woudld compromise the applicability of test data to the goals of the project, it is not a version of PyPy after all, merely an executable file compiled using the same tools. Beyond this another problem exists though, it is not possible to design the executable in such a way that it can either generate new data for sorting or read generated data from files in dynamic way. Whilst it is possible to use a library such as random to generate a random list, or to read from files to assemble a list, this must be performed outside of the code block run by RPython, it is instead run by the version of PyPy that is called to run the file \textit{rpython} and the variables it generates are stored within the executable, meaning the first random list generated is always stored and the values read from a file remain the same even if the file is edited.
\subsubsection{Profiling}
A tool utilised to test the performance of solutions was a line profiler for Python, in this project the open source utility line\textunderscore profiler \cite{lineprof} was used. This tool runs a python script and returns information about executed code within a function, namely the execution time of each line per call, the number of calls of each line, the total number of times a line was called and the time taken by calling the line as a percentage of the total execution time of the script.
\par 
It is important to note that this tool runs using Python, not PyPy and also that as theis project demands a compiled piece of code written in RPython the results regarding time taken must not be taken as too strongly indicative of the performance of a solution. It was also necessary to make minor changes to the code such as replacing \textit{xrange} with the equivalent \textit{range} and \textit{sys.maxint} with \textit{sys.maxsize}.
\par 
The data provided by this tool was, however, very useful at identifying the correctness of solutions as the number of calls to a particular line would be identical whether run using line\textunderscore profiler or with a compiled version of PyPy, provided the input list is identical. Using this information allowed me to ensure that the code was efficient and that unnecessary iterations over the input list were not made. As an example this tool allowed me to identify that pigeonhole sort was incorrectly performing an additional iteration by showing that all lists made up of positive integers triggered the condition of a single bucket containing all items.
\par

\begin{table}[H]
	\centering
	\makebox[\linewidth][]{
	\resizebox{1.1\linewidth}{!}{
		\centering
	% \mbox{
	\begin{tabular}{rrrrrl}
		\hline
		Line \# & Hits   & Time   & Per Hit   & \% Time   & Line Contents                                                       \\
	 \hline
	 109 &       &        &        &      &  \lstinline{@profile}\\
	 110 &       &        &        &      &  \lstinline{def sort(self):}\\
	 111 & 1     & 1.9    & 1.9    & 0.0  &  \;\;\;\;\lstinline{    if self.list_length < 2:}\\
	 112 &       &        &        &      &  \;\;\;\;\;\;\;\;\lstinline{        return}\\
	 113 & 1     & 8738.5 & 9000.0 & 23.5 &  \;\;\;\;\lstinline{    list_max = self.list_abs_max()}\\
	 114 & 1     & 9.5    & 9.5    & 0.0  &  \;\;\;\;\lstinline{    list_max_digits = int_digits(list_max, self.base)}\\
	 115 & 1     & 0.3    & 0.3    & 0.0  &  \;\;\;\;\lstinline{    if self.ordered:}\\
	 116 &       &        &        &      &  \;\;\;\;\;\;\;\;\lstinline{        return}\\
	 117 & 1     & 0.3    & 0.3    & 0.0  &  \;\;\;\;\lstinline{    if self.reverse_ordered:}\\
	 118 &       &        &        &      &  \;\;\;\;\;\;\;\;\lstinline{        self.reverse_slice()}\\
	 119 &       &        &        &      &  \;\;\;\;\;\;\;\;\lstinline{        return}\\
	 120 & 1     & 30.4   & 30.4   & 0.1  &  \;\;\;\;\lstinline{    max_bits = int(int_digits(list_max, 1))}\\
	 121 & 1     & 0.7    & 0.7    & 0.0  &  \;\;\;\;\lstinline{    bit_mask = ~((1 << max_bits) - 1)}\\
	 122 & 1     & 0.9    & 0.9    & 0.0  &  \;\;\;\;\lstinline{    if max_bits \% self.base == 0 and max_bits != int_digits(}\\
	 123 &       &        &        &      &  \;\;\;\;\;\;\;\;\lstinline{        (-sys.maxsize) - 1, 1}\\
	 124 &       &        &        &      &  \;\;\;\;\lstinline{    ):}\\
	 125 &       &        &        &      &  \;\;\;\;\;\;\;\;\lstinline{        list_max_digits += 1}\\
	 126 & 1     & 9.9    & 9.9    & 0.0  &  \;\;\;\;\lstinline{    bucket_list = [[] for _ in range(self.radix)]}\\
	 127 & 5     & 1.6    & 0.3    & 0.0  &  \;\;\;\;\lstinline{    for i in range(list_max_digits):}\\
	 128 & 4     & 1.6    & 0.4    & 0.0  &  \;\;\;\;\;\;\;\;\lstinline{        shift = (self.base) * i}\\
	 129 & 40004 & 4158.5 & 0.1    & 11.2 &  \;\;\;\;\;\;\;\;\lstinline{        for num in self.list:}\\
	 130 & 40000 & 6395.9 & 0.2    & 17.2 &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            masked_input = num ^ bit_mask}\\
	 131 & 40000 & 9121.8 & 0.2    & 24.5 &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            curr_digit = (masked_input >> shift) & self.radix - 1}\\
	 132 & 40000 & 8222.3 & 0.2    & 22.1 &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            bucket_list[curr_digit].append(num)}\\
	 133 & 8     & 117.4  & 14.7   & 0.3  &  \;\;\;\;\;\;\;\;\lstinline{        nonempty = [}\\
	 134 &       &        &        &      &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            (bdx, bucket)}\\
	 135 & 4     & 6.1    & 1.5    & 0.0  &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            for bdx, bucket in enumerate(bucket_list)}\\
	 136 &       &        &        &      &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            if bucket != []}\\
	 137 &       &        &        &      &  \;\;\;\;\;\;\;\;\lstinline{        ]}\\
	 138 & 4     & 3.6    & 0.9    & 0.0  &  \;\;\;\;\;\;\;\;\lstinline{        if len(nonempty) == 1:}\\
	 139 &       &        &        &      &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            bucket_list[nonempty[0][0]] = []}\\
	 140 &       &        &        &      &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            continue}\\
	 141 & 4     & 1.0    & 0.3    & 0.0  &  \;\;\;\;\;\;\;\;\lstinline{        index = 0}\\
	 142 & 260   & 37.6   & 0.1    & 0.1  &  \;\;\;\;\;\;\;\;\lstinline{        for bdx, bucket in enumerate(bucket_list):}\\
	 143 & 256   & 41.8   & 0.2    & 0.1  &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            if len(bucket) == 0: continue}\\
	 144 & 200   & 257.8  & 1.3    & 0.7  &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            self.setslice(bucket, index)}\\
	 145 & 200   & 36.1   & 0.2    & 0.1  &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            index += len(bucket)}\\
	 146 & 200   & 37.1   & 0.2    & 0.1  &  \;\;\;\;\;\;\;\;\;\;\;\;\lstinline{            bucket_list[bdx] = []}\\
	 \hline
		\end{tabular}
		}}
		\caption*{line\textunderscore profiler output of LSD Counting sort}
	\end{table}
\subsubsection{Test parameters}
In order to properly asses the efficacy of a solution, it must be tested in a range of environments
{\color{red} Talk aobut how testing was only a secondary evaluation method to using minimizing time complexity due to the difference in machines}
\pagebreak
\printbibliography
\end{document}